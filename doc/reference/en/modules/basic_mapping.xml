<!-- 
	before committing make sure to comment out the DOCTYPE
	It is in here to get intellisense with XMLSpy.  The
	HomeEdition is a free download.

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "../../support/docbook-dtd/docbookx.dtd">
-->
<chapter id="mapping">
	<title>Basic O/R Mapping</title>

	<sect1 id="mapping-declaration">
		<title>Mapping declaration</title>

		<para>
			Object/relational mappings are defined in an XML document. The mapping document
			is designed to be readable and hand-editable. The mapping language is .NET-centric,
			meaning that mappings are constructed around persistent class declarations, not
			table declarations.
		</para>
	
		<para>
			Note that, even though many Hibernate users choose to define XML mappings be hand,
			a number of tools exist to generate the mapping document, including XDoclet,
			Middlegen and AndroMDA.
		</para>

		<para>
			Lets kick off with an example mapping:
		</para>

		<programlisting><![CDATA[
<?xml version="1.0" ?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.0">

        <class name="Eg.Cat, Eg" table="CATS" discriminator-value="C">
                <id name="Id" column="uid" type="Int64">
                        <generator class="hilo"/>
                </id>
                <discriminator column="subclass" type="Char"/>
                <property name="Birthdate" type="Date"/>
                <property name="Color" not-null="true"/>
                <property name="Sex" not-null="true" update="false"/>
                <property name="Weight"/>
                <many-to-one name="Mate" column="mate_id"/>
                <set name="Kittens">
                        <key column="mother_id"/>
                        <one-to-many class="Eg.Cat, Eg"/>
                </set>
                <subclass name="Eg.DomesticCat, Eg" discriminator-value="D">
                        <property name="Name" type="String"/>
                </subclass>
        </class>

        <class name="Eg.Dog, Eg">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>
]]></programlisting>

		<para>
				We will now discuss the content of the mapping document. We will only describe the 
				document elements and attributes that are used by Hibernate at runtime. The mapping 
				document also contains some extra optional attributes and elements that affect the 
				database schemas exported by the schema export tool. (For example the <literal>
				not-null</literal> attribute.)
		</para>

		<sect2 id="mapping-declaration-doctype">
			<title>Schema</title>

			<para>
				All XML mappings have to use the nhibernate-mapping-2.0 schema. The actual schema may be found 
				in the NHibernate source directory, or as an Embedded Resource in <literal>NHibernate.dll</literal>. 
				NHibernate will always use the Embedded Resource as the source for the schema.
			</para>
			
			<para>
				To get intellisense while working with the <literal>hibernate-mapping</literal> xml inside of VisualStudio.NET 
				you should copy the schema to the folder 
				<literal>C:\Program Files\Microsoft Visual Studio .NET 2003\Common7\Packages\schemas\xml</literal>
			</para>
		</sect2>

		<sect2 id="mapping-declaration-mapping">
			<title>hibernate-mapping</title>

			<para>
				This element has four optional attributes. The <literal>schema</literal> attribute
				specifies that tables referred to by this mapping belong to the named schema. If specified, 
				tablenames will be qualified by the given schema name. If missing, tablenames will be 
				unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style
				should be assumed for properties and collections which do not specify a 
				<literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us
				use unqualified class names in the query language, by default.  The <literal>default-access</literal>
				attribute tells us how to access property values.
			</para>
 
			
			<programlisting> 
&lt;hibernate-mapping
         schema="schemaName" <co id="hm1-co" linkends="hm1" />
         default-cascade="none|save-update" <co id="hm2-co" linkends="hm2" />
         auto-import="true|false" <co id="hm3-co" linkends="hm3" />
         default-access="property|field|nosetter|ClassName" <co id="hm4-co" linkends="hm4" />
 &gt;
			</programlisting>
			<calloutlist>
					<callout arearefs="hm1-co" id="hm1">
						<para>
							<literal>schema</literal> (optional): The name of a database schema.
						</para>
					</callout>
	
					<callout arearefs="hm2-co" id="hm2">
						<para>
							<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): 
							A default cascade style.
						</para>
					</callout>
	
					<callout arearefs="hm3-co" id="hm3">
						<para>
							<literal>auto-import</literal> (optional - defaults to <literal>true</literal>):
							Specifies whether we can use unqualified class names (of classes in this mapping)
							in the query language.
						</para>
					</callout>
					<callout arearefs="hm4-co" id="hm4">
						<para>
							<literal>default-access</literal> (optional - defaults to <literal>property</literal>):
							The strategy NHibernate should use for accessing the property value.
						</para>
					</callout>
					
				</calloutlist>
			
			<para>
				If you have two persistent classes with the same (unqualified) name, you should set 
				<literal>auto-import="false"</literal>. NHibernate will throw an exception if you attempt
				to assign two classes to the same "imported" name.
			</para>
	
		</sect2>
		<sect2 id="mapping-declaration-class">
			<title>class</title>

			<para>
				You may declare a persistent class using the <literal>class</literal> element:
			</para>
	        
			
				
			<programlisting>&lt;class
        name="ClassName" <co id="class1-co" linkends="class1" />
        table="tableName"<co id="class2-co" linkends="class2" />
        discriminator-value="discriminator_value"<co id="class3-co" linkends="class3" />
        mutable="true|false"<co id="class4-co" linkends="class4" />
        schema="owner"<co id="class5-co" linkends="class5" />
        proxy="ProxyInterface"<co id="class6-co" linkends="class6" />
        dynamic-update="true|false"<co id="class7-co" linkends="class7" />
        dynamic-insert="true|false"<co id="class8-co" linkends="class8" />
        polymorphism="implicit|explicit"<co id="class9-co" linkends="class9" />
        where="arbitrary sql where condition"<co id="class10-co" linkends="class10" />
        persister="PersisterClass"<co id="class11-co" linkends="class11" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="class1-co" id="class1">
					<para>
						<literal>name</literal>: The fully qualified .NET Type name of the persistent class 
						(or interface).
					</para>
				</callout>
				<callout arearefs="class2-co" id="class2">
					<para>
						<literal>table</literal>: The name of its database table.
					</para>
				</callout>
				<callout arearefs="class3-co" id="class3">
					<para>
						<literal>discriminator-value</literal> (optional - defaults to the class name): A value
						that distiguishes individual subclasses, used for polymorphic behaviour.
					</para>
				</callout>
				<callout arearefs="class4-co" id="class4">
					<para>
						<literal>mutable</literal> (optional, defaults to <literal>true</literal>): Specifies 
						that instances of the class are (not) mutable.
					</para>
				</callout>    
				<callout arearefs="class5-co" id="class5">
					<para>
						<literal>schema</literal> (optional): Override the schema name specified by
						the root <literal>&lt;hibernate-mapping&gt;</literal> element.
					</para>
				</callout>                
				<callout arearefs="class6-co" id="class6">
					<para>
						<literal>proxy</literal> (optional): Specifies an interface to use for lazy
						initializing proxies. You may specify the name of the class itself as long as 
						all Properties are virtual.
					</para>
				</callout>    
				<callout arearefs="class7-co" id="class7">
					<para>
						<literal>dynamic-update</literal> (optional, defaults to <literal>false</literal>): 
						Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and 
						contain only those columns whose values have changed.
					</para>
				</callout>    
				<callout arearefs="class8-co" id="class8">
					<para>
						<literal>dynamic-insert</literal> (optional, defaults to <literal>false</literal>): 
						Specifies that <literal>INSERT</literal> SQL should be generated at runtime and 
						contain only the columns whose values are not null.
					</para>
				</callout>    
				<callout arearefs="class9-co" id="class9">
					<para>
						<literal>polymorphism</literal> (optional, defaults to <literal>implicit</literal>): 
						Determines whether implicit or explicit query polymorphism is used.
					</para>
				</callout>    
				<callout arearefs="class10-co" id="class10">
					<para>
						<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> 
						condition to be used when retrieving objects of this class
					</para>
				</callout>                 
				<callout arearefs="class11-co" id="class11">
					<para>
						<literal>persister</literal> (optional): Specifies a custom <literal>IClassPersister</literal>.
					</para>
				</callout>                 
			</calloutlist>
	
			<para>
				It is perfectly acceptable for the named persistent class to be an interface. You would then
				declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal>
				element. You may persist any inner class. You should specify the
				class name using the standard form ie. <literal>Eg.Foo+Bar</literal>.
			</para>

			<para>
				Immutable classes, <literal>mutable="false"</literal>, may not be updated or deleted by the 
				application. This allows NHibernate to make some minor performance optimizations.
			</para>
	        
			<para>
				The optional <literal>proxy</literal> attribute enables lazy initialization of persistent
				instances of the class. NHibernate will initially return proxies generated by Castle.DynamicProxy
				which implement the named interface or extend the class. The actual persistent object will be 
				loaded when a method of the proxy is invoked. See "Proxies for Lazy Initialization" below.
			</para>
	        
			<para><emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned
				by a query that names any superclass or implemented interface or the class and that instances
				of any subclass of the class will be returned by a query that names the class itself. 
				<emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only
				be queries that explicitly name that class and that queries that name the class will return
				only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration
				as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For
				most purposes the default, <literal>polymorphism="implicit"</literal>, is appropriate.
				Explicit polymorphism is useful when two different classes are mapped to the same table
				(this allows a "lightweight" class that contains a subset of the table columns).
			</para>
	        
			<para>
				The <literal>persister</literal> attribute lets you customize the persistence strategy used for
				the class. You may, for example, specify your own subclass of 
				<literal>NHibernate.Persister.EntityPersister</literal> or you might even provide a
				completely new implementation of the interface 
				<literal>NHibernate.Persister.IClassPersister</literal> that implements persistence via,
				for example, stored procedure calls, serialization to flat files or LDAP. See
				<literal>NHibernate.DomainModel.CustomPersister</literal> for a simple example (of "persistence"
				to a <literal>Hashtable</literal>).
			</para>
	        
			<para>
				Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal>
				settings are not inherited by subclasses and so may also be specified on the
				<literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements. 
				These settings may increase performance in some cases, but might actually decrease 
				performance in others. Use judiciously.
			</para>
	        
		</sect2>

		<sect2 id="mapping-declaration_id">
			<title>id</title>

			<para>
				Mapped classes <emphasis>must</emphasis> declare the primary key column of the database 
				table. Most classes will also have a Property holding the unique identifier 
				of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that
				property to the primary key column.
			</para>
	
			<programlisting>&lt;id 
        name="propertyName" <co id="id1-co" linkends="id1" />
        type="typename" <co id="id2-co" linkends="id2" />
        column="column_name" <co id="id3-co" linkends="id3" />
        unsaved-value="any|none|null|id_value" <co id="id4-co" linkends="id4" />
        access="field|property|nosetter|ClassName"&gt; <co id="id5-co" linkends="id5" />

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;		</programlisting>
			<calloutlist>
				<callout arearefs="id1-co" id="id1">
					<para>
						<literal>name</literal> (optional): The name of the identifier property.
					</para>
				</callout>
				<callout arearefs="id2-co" id="id2">
					<para>
						<literal>type</literal> (optional): A name that indicates the NHibernate type.
					</para>
				</callout>
				<callout arearefs="id3-co" id="id3">
					<para>
						<literal>column</literal> (optional - defaults to the property name): The
						name of the primary key column.
					</para>
				</callout>
				<callout arearefs="id4-co" id="id4">
					<para>
						<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): 
						An identifier property value that indicates that an instance is newly instantiated
						(unsaved), distinguishing it from transient instances that were saved or loaded
						in a previous session.
					</para>
				</callout>            
				<callout arearefs="id5-co" id="id5">
					<para>
						<literal>access</literal> (optional - defaults to <literal>property</literal>): The
						strategy NHibernate should use for accessing the property value.
					</para>
				</callout>
			</calloutlist>
			
			
			<para>
				If the <literal>name</literal> attribute is missing, it is assumed that the class has no 
				identifier property.
			</para>
	        
			<para>
				The <literal>unsaved-value</literal> attribute is important! If the identfier property of your 
				class does not default to <literal>null</literal>, then you should specify the actual default.
				This is especially important when using a <literal>System.ValueType</literal> such as 
				<literal>System.Int32</literal> or <literal>System.Guid</literal> as your <literal>&lt;id&gt;</literal>
				 property.  Make sure to explicity set this attribute because <literal>System.ValueType</literal> 
				objects can not be <literal>null</literal>.
			</para>

			<para>
				There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to
				legacy data with composite keys. We strongly discourage its use for anything else.
			</para>
			
			<sect3 id="mapping-declaration-id-generator">
                <title>generator</title>

                <para>
                    The required <literal>&lt;generator&gt;</literal> child element names a .NET type used
                    to generate unique identifiers for instances of the persistent class. If any parameters
                    are required to configure or initialize the generator instance, they are passed using the
                    <literal>&lt;param&gt;</literal> element.
                </para>

				<programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0">
        <generator class="NHibernate.Id.TableHiLoGenerator">
                <param name="table">uid_table</param>
                <param name="column">next_hi_value_column</param>
        </generator>
</id>]]></programlisting>

				<para>
                    All generators implement the interface <literal>NHibernate.Id.IdentifierGenerator</literal>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, NHibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:
                    
                    <variablelist>
                        <varlistentry>
                        <term><literal>identity</literal></term>
                        <listitem>
                            <para>
                                supports identity columns in DB2, MySQL, MS SQL Server, Sybase and
                                HypersonicSQL. The returned identifier is of type <literal>Int64</literal>,
                                <literal>Int32</literal> or <literal>Int16</literal>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence</literal></term>
                        <listitem>
                            <para>
                                uses a sequence in DB2, PostgreSQL, Oracle. The returned identifier 
                                is of type <literal>Int64</literal>,
                                <literal>Int32</literal> or <literal>Int16</literal>
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>hilo</literal></term>
                        <listitem>
                            <para>
                                uses a hi/lo algorithm to efficiently generate identifiers of
                                type <literal>Int64</literal>, <literal>Int32</literal> or <literal>Int16</literal>,
                                given a table and column (by default <literal>hibernate_unique_key</literal> and
                                <literal>next</literal> respectively) as a source of hi values. The hi/lo algorithm
                                generates identifiers that are unique only for a particular database.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>seqhilo</literal></term>
                        <listitem>
                            <para>
                                uses a hi/lo algorithm to efficiently generate identifiers of type
                                <literal>Int64</literal>, <literal>Int32</literal> or <literal>Int16</literal>,
                                given a named database sequence.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid.hex</literal></term>
                        <listitem>
                            <para>
                                uses <literal>System.Guid</literal> and its <literal>ToString(string format)</literal> method
                                to generate identifiers of type string.  The length of the string returned depends on the 
                                configured <literal>format</literal>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid.string</literal></term>
                        <listitem>
                            <para>
                                uses a new <literal>System.Guid</literal> to create a <literal>byte[]</literal> that is
                                converted to a string.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid</literal></term>
                        <listitem>
                            <para>
                                uses a new <literal>System.Guid</literal> as the identifier.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid.comb</literal></term>
                        <listitem>
                            <para>
                                uses the algorithm to generate a new <literal>System.Guid</literal>
                                described by Jimmy Nilsson in the article 
                                http://www.informit.com/articles/article.asp?p=25862.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>native</literal></term>
                        <listitem>
                            <para>
                                picks <literal>identity</literal>, <literal>sequence</literal> or
                                <literal>hilo</literal> depending upon the capabilities of the
                                underlying database.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>assigned</literal></term>
                        <listitem>
                            <para>
                                lets the application to assign an identifier to the object before
                                <literal>save()</literal> is called.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>foreign</literal></term>
                        <listitem>
                            <para>
                                uses the identifier of another associated object. Usually used in conjunction
                                with a <literal>&lt;one-to-one&gt;</literal> primary key association.
                            </para>
                        </listitem>
                        </varlistentry>
                    </variablelist>

                </para>
            </sect3>
            
            
            <sect3 id="mapping-declaration-id-hilo">
                <title>Hi/Lo Algorithm</title>
                <para>
                    The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
        <generator class="hilo">
                <param name="table">hi_value</param>
                <param name="column">next_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
        <generator class="seqhilo">
                <param name="sequence">hi_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <para>
                    Unfortunately, you can't use <literal>hilo</literal> when supplying your own
                    <literal>Connection</literal>  to NHibernate. NHibernate must be able to
                    fetch the "hi" value in a new transaction.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid-hex">
                <title>UUID Hex Algorithm</title>

                <programlisting><![CDATA[<id name="Id" type="String" column="cat_id">
        <generator class="uuid.hex">
                <param name="format">format_value</param>
                <param name="seperator">seperator_value</param>
        </generator>
</id>]]></programlisting>

                <para>
					The UUID is generated by calling <literal>Guid.NewGuid().ToString(format)</literal>.  The
					valid values for format are described in the MSDN documentation.  The default 
					<literal>seperator</literal> is <literal>-</literal> and should rarely be modified.  The
					<literal>format</literal> determines if the configured <literal>seperator</literal> can 
					replace the default seperator used by the <literal>format</literal>.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid-string">
                <title>UUID String Algorithm</title>
                <para>
					The UUID is generated by calling <literal>Guid.NewGuid().ToByteArray()</literal> and 
					then converting the <literal>byte[]</literal> into a <literal>char[]</literal>.  The
					<literal>char[]</literal> is returned as a <literal>String</literal> consisting of
					16 characters.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-guid">
                <title>GUID Algorithms</title>
                <para>
					The <literal>guid</literal> identifier is generated by calling <literal>Guid.NewGuid()</literal>.
					To address some of the performance concerns with using Guids as primary keys, foreign keys, and
					as part of indexes with MS SQL the <literal>guid.comb</literal> can be used.  The benefit of using  
					the <literal>guid.comb</literal> with other databases that support GUIDs has not been measured.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-sequences">
				<title>Identity columns and Sequences</title>
                <para>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <literal>identity</literal> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL) you may use
                    <literal>sequence</literal> style key generation. Both these strategies usually require
                    two SQL queries to insert a new object.  When working with MS SQL and the 
                    <literal>identity</literal> key generator then <literal>select SCOPE_IDENTITY()</literal>
                    will be appended to the <literal>insert</literal> sql thus avoiding the executions
                    of a two distinct <literal>IDbCommand</literal>s.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid">
        <generator class="sequence">
                <param name="sequence">uid_sequence</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0">
        <generator class="identity"/>
</id>]]></programlisting>
            
                <para>
                    For cross-platform development, the <literal>native</literal> strategy will
                    choose from the <literal>identity</literal>, <literal>sequence</literal> and
                    <literal>hilo</literal> strategies, dependant upon the capabilities of the
                    underlying database.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-assigned">
                <title>Assigned Identifiers</title>
                <para>
                    If you want the application to assign identifiers (as opposed to having
                    NHibernate generate them), you may use the <literal>assigned</literal> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. Be very careful when using this feature to not assign
                    keys with business meaning (almost always a terrible design decision).
                </para>
                <para>
                    Due to its inherent nature, entities that use this generator cannot be saved
                    via the ISession's <literal>SaveOrUpdate()</literal> method. Instead you have to 
                    explicitly specify to NHibernate if the object should be saved or updated 
                    by calling either the <literal>Save()</literal> or <literal>Update()</literal> 
                    method of the ISession.
                </para>
            </sect3>
		</sect2>
		
		<sect2 id="mapping-declaration-compositeid">
            <title>composite-id</title>

            <programlisting>&lt;composite-id
        name="propertyName"<co id="composite-id1-co" linkends="composite-id1" />
        class="ClassName"<co id="composite-id2-co" linkends="composite-id2" />
        unsaved-value="any|none"<co id="composite-id3-co" linkends="composite-id3" />
        access="field|property|nosetter|ClassName"&gt;

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</programlisting>

			<para>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <literal>&lt;composite-id&gt;</literal> element
                accepts <literal>&lt;key-property&gt;</literal> property mappings and
                <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements.
            </para>
            
            <programlisting><![CDATA[<composite-id>
        <key-property name="medicareNumber"/>
        <key-property name="dependent"/>
</composite-id>]]></programlisting>

            <para>
                Your persistent class <emphasis>must</emphasis> override <literal>Equals()</literal>
                and <literal>GetHashCode()</literal> to implement composite identifier equality. It must
                also be <literal>Serializable</literal>.
            </para>

            <para>
                Unfortunately, this approach to composite identifiers means that a persistent object 
                is its own identifier. There is no convenient "handle" other than the object itself. 
                You must instantiate an instance of the persistent class itself and populate its 
                identifier properties before you can <literal>Load()</literal> the persistent state
                associated with a composite key. We will describe a much more
                convenient approach where the composite identifier is implemented as a seperate class
                in TODO:LINKTOCOMPENENTS<!--<xref linkend="components-compositeid"/>-->. The attributes described below apply only
                to this alternative approach:
            </para>
			
			<calloutlist>
				<callout arearefs="composite-id1-co" id="composite-id1">
					<para>
						<literal>name</literal> (optional): A property of component type that holds the
                        composite identifier (see next section).
					</para>
				</callout>  
				<callout arearefs="composite-id2-co" id="composite-id2">
					<para>
						<literal>class</literal> (optional - defaults to the property type determined by 
                        reflection): The component class used as a composite identifier (see next section).
					</para>
				</callout>  
				<callout arearefs="composite-id3-co" id="composite-id3">
					<para>
						<literal>unsaved-value</literal> (optional - defaults to <literal>none</literal>): 
                        Indicates that transient instances should be considered newly instantiated, if set 
                        to <literal>any</literal>.
					</para>
				</callout>  
			</calloutlist> 
            
        </sect2>
        
        <sect2 id="mapping-declaration-discriminator">
            <title>discriminator</title>

            <para>
                The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence 
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the 
                table. The discriminator column contains marker values that tell the persistence layer what 
                subclass to instantiate for a particular row. A restricted set of types may be used: 
                <literal>String</literal>, <literal>Char</literal>, <literal>Int32</literal>, 
                <literal>Byte</literal>, <literal>Int16</literal>, <literal>Boolean</literal>, 
                <literal>YesNo</literal>, <literal>TrueFalse</literal>.
            </para>
            
            <programlistingco>
                <programlisting>&lt;discriminator
        column="discriminator_column"<co id="discriminator1-co" linkends="discriminator1" />
        type="discriminator_type"<co id="discriminator2-co" linkends="discriminator2" />
        force="true|false"<co id="discriminator3-co" linkends="discriminator3" />
/&gt;</programlisting>
                <calloutlist>
                    <callout arearefs="discriminator1-co" id="discriminator1">
                        <para>
                            <literal>column</literal> (optional - defaults to <literal>class</literal>) the
                            name of the discriminator column.
                        </para>
                    </callout>
                    <callout arearefs="discriminator2-co" id="discriminator2">
                        <para>
                            <literal>type</literal> (optional - defaults to <literal>String</literal>) a
                            name that indicates the Hibernate type
                        </para>
                    </callout>          
                    <callout arearefs="discriminator3-co" id="discriminator3">
                        <para>
                            <literal>force</literal> (optional - defaults to <literal>false</literal>) 
                            "force" NHibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </para>
                    </callout>          
                </calloutlist>
            </programlistingco>

            <para>
                Actual values of the discriminator column are specified by the
                <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and
                <literal>&lt;subclass&gt;</literal> elements.
            </para>
            
            <para>
                The <literal>force</literal> attribute is (only) useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-version">
            <title>version (optional)</title>
            
            <para>
                The <literal>&lt;version&gt;</literal> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <emphasis>long transactions</emphasis> (see below).
            </para>
            
            <programlistingco>
                <programlisting>&lt;version
        column="version_column"<co id="version1-co" linkends="version1" />
        name="propertyName"<co id="version2-co" linkends="version2" />
        type="typename"<co id="version3-co" linkends="version3" />
        access="field|property|nosetter|ClassName"<co id="version4-co" linkends="version4" />
/&gt;</programlisting>
                <calloutlist>
                    <callout arearefs="version1-co" id="version1">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </para>
                    </callout>          
                    <callout arearefs="version2-co" id="version2">
                        <para>
                            <literal>name</literal>: The name of a property  of the persistent class.
                        </para>
                    </callout>
                    <callout arearefs="version3-co" id="version3">
                        <para>
                            <literal>type</literal> (optional - defaults to <literal>Int32</literal>): 
                            The type of the version number.
                        </para>
                    </callout>          
                   <callout arearefs="version4-co" id="version4">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Version numbers may be of type <literal>Int64</literal>, <literal>Int32</literal>,
                <literal>Int16</literal>, <literal>Ticks</literal>, <literal>Timestamp</literal>, 
                or <literal>TimeSpan</literal>.
            </para>

        </sect2>
        	
		<sect2 id="mapping-declaration-timestamp">
            <title>timestamp (optional)</title>

            <para>
                The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </para>
            
            <programlistingco>      
                <programlisting>&lt;timestamp
        column="timestamp_column"<co id="timestamp1-co" linkends="timestamp1" />
        name="propertyName"<co id="timestamp2-co" linkends="timestamp2" />
        access="field|property|nosetter|ClassName"<co id="timestamp3-co" linkends="timestamp3" />
/&gt;</programlisting>
                <calloutlist>
                    <callout arearefs="timestamp1-co" id="timestamp1">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </para>
                    </callout>                   
                    <callout arearefs="timestamp2-co" id="timestamp2">
                        <para>
                            <literal>name</literal>: The name of a property of .NET type <literal>DateTime</literal>.
                        </para>
                    </callout>
                   <callout arearefs="timestamp3-co" id="timestamp3">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Note that <literal>&lt;timestamp&gt;</literal> is equivalent to 
                <literal>&lt;version type="timestamp"&gt;</literal>.
            </para>
        </sect2>

		<sect2 id="mapping-declaration-property">
			<title>property</title>

			<para>
				The <literal>&lt;property&gt;</literal> element declares a persistent, 
				property of the class.
			</para>
	        
			<programlisting>&lt;property
        name="propertyName"<co id="property1-co" linkends="property1" />
        column="column_name"<co id="property2-co" linkends="property2" />
        type="typename"<co id="property3-co" linkends="property3" />
        update="true|false"<co id="property4-co" linkends="property4" />
        insert="true|false"<co id="property5-co" linkends="property5" />
        formula="arbitrary SQL expression"<co id="property6-co" linkends="property6" />
        access="field|property|nosetter|ClassName"<co id="property7-co" linkends="property7" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="property1-co" id="property1">
					<para>
						<literal>name</literal>: the name of the property in the same case as the Propery in your API
					</para>
				</callout>                   
				<callout arearefs="property2-co" id="property2">
					<para>
						<literal>column</literal> (optional - defaults to the property name): the name
						of the mapped database table column.
					</para>
				</callout>
				<callout arearefs="property3-co" id="property3">
					<para>
						<literal>type</literal> (optional): a name that indicates the NHibernate type.
					</para>
				</callout>
				<callout arearefs="property4-co" id="property4">
					<para>
						<literal>update</literal> (optional - defaults to <literal>true</literal>) :
						specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> 
					</para>
				</callout>
				<callout arearefs="property5-co" id="property5">
					<para>
						<literal>insert</literal> (optional - defaults to <literal>true</literal>) :
						specifies that the mapped columns should be included in SQL 
						<literal>INSERT</literal> statements. Setting both <literal>insert</literal>
						and <literal>update</literal> to <literal>false</literal>
						allows a pure "derived" property whose value is initialized from some other
						property that maps to the same colum(s) or by a trigger or other application.
					</para>
				</callout>
				<callout arearefs="property6-co" id="property6">
					<para>
						<literal>formula</literal> (optional): an SQL expression that defines the value for a
						<emphasis>computed</emphasis> property. Computed properties do not have a column
						mapping of their own.
					</para>
				</callout>
				<callout arearefs="property7-co" id="property7">
					<para>
						<literal>access</literal> (optional - defaults to <literal>property</literal>): The
						strategy NHibernate should use for accessing the property value.
					</para>
				</callout>
			</calloutlist>

			<para>
				<emphasis>typename</emphasis> could be:
			</para>

			<orderedlist spacing="compact">
				<listitem>
					<para>
						The name of a NHibernate basic type (eg. <literal>Int32, String, Char,
						DateTime, Timstamp, Single, Byte[], Object, ...</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a .NET type with a default basic type (eg. <literal>System.Int16, System.Single,
						System.Char, System.String, System.DateTime, System.Byte[], ...</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a your of <literal>System.Enum </literal> (eg. <literal>Eg.Color</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a serializable .NET type.
					</para>
				</listitem>
				<listitem>
					<para>
						The type of a custom type (eg. <literal>Illflow.Type.MyCustomType, Illflow</literal>).
					</para>
				</listitem>
			</orderedlist>

			<para>
				If you do not specify a type, NHibernate will use reflection upon the named
				property to take a guess at the correct NHibernate type. NHibernate will try to
				interpret the name of the return class of the property getter using rules 2, 3,
				4 in that order. However, this is not always enough.
				In certain cases you will still need the <literal>type</literal>
				attribute. (For example, to distinguish between <literal>NHibernate.DateTime</literal> and
				<literal>NHibernate.Timestamp</literal>, or to specify a custom type.)
			</para>
			
			<para>
				The <literal>access</literal> attribute lets you control how NHibernate will access
				the value of the property at runtime.  The value of the <literal>access</literal> attribute should
				be text formatted as <literal>access-strategy.naming-strategy</literal>.  The 
				<literal>.naming-stragey</literal> is not always required.
				<table>
					<title>Access Strategy</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Access Strategy Name</entry>
								<entry>Description</entry>	
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>property</literal></entry>
								<entry>
									<para>
										The default implementation.  NHibernate uses the get/set of your Property.  No
										Naming Strategy should be used with this Access Strategy because the 
										<literal>name</literal> attribute is the name of the Property.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>field</literal></entry>
								<entry>
									<para>
										NHibernate will access the Field directly.  NHibernate uses the <literal>&lt;name&gt;</literal>
										as the name of the field.  This can be used when a Property's get and set have extra
										actions in them that you don't want to occur when NHibernate is populating or reading the object.  
										If you want the name of the Property and not the Field to be what the consumers of your API 
										use with HQL, then a Naming Strategy is needed.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>nosetter</literal></entry>
								<entry>
									<para>
										NHibernate will access the Field directly when setting the value and will use the
										Property when getting the value.  This can be used when a Property only exposes a get because
										the consumers of your API can't change the value directly.  A Naming Strategy is required
										because NHibernate uses the <literal>name</literal> attribute as the Property so it needs to 
										be told what the name of the Field is.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>ClassName</literal></entry>
								<entry>
									<para>
										If NHibernate's built in Access Strategies are not what is needed for your situation
										then you can build your own by implementing the interface 
										<literal>NHibernate.Property.IPropertyAccessor</literal>.  The value of the 
										<literal>access</literal> attribute should be an Assembly Qualified Name that can be 
										loaded with <literal>Activator.CreateInstance(string AssemblyQualifiedName)</literal>.
									</para>
								</entry>	
							</row>	
						</tbody>	
					</tgroup>		
				</table>
			</para>
			
			<para>
				<table>
					<title>Naming Strategy</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Naming Strategy Name</entry>
								<entry>Description</entry>	
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>camelcase</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is converted to CamelCase to find the Field.
										<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>foo</literal>.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>camelcase-underscore</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is converted to CamelCase and prefixed with an
										underscore to find the Field.
										<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>_foo</literal>.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>lowercase-underscore</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is converted to all LowerCase and prefixed with an
										underscore to find the Field.
										<literal>&lt;property name="FooBar" ... &gt;</literal> uses the Field <literal>_foobar</literal>.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>pascalcase-m-underscore</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is prefixed with the character
										<literal>m</literal> and an underscore to find the Field.
										<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>m_Foo</literal>.
									</para>
								</entry>	
							</row>	
						</tbody>
					</tgroup>
				</table>
			</para>
		</sect2>
		<!--
		TODO: resume here
		<sect2 id="mapping-declaration-manytoone">
		-->
	</sect1>
	<sect1 id="mapping-types">
		<title>NHibernate Types</title>
		<sect2 id="mapping-types-entitiesvalues">
			<title>Entities and values</title>

			<para>
				To understand the behaviour of various .NET language-level objects with respect
				to the persistence service, we need to classify them into two groups:
			</para>

			<para>
				An <emphasis>entity</emphasis> exists independently of any other objects holding
				references to the entity. Contrast this with the usual .NET model where an
				unreferenced object is garbage collected. Entities must be explicitly saved and
				deleted (except that saves and deletions may be <emphasis>cascaded</emphasis>
				from a parent entity to its children).  Entities support
				circular and shared references. They may also be versioned.
			</para>

			<para>
				An entity's persistent state consists of references to other entities and
				instances of <emphasis>value</emphasis> types. Values are structs,
				collections, components and certain immutable objects. Unlike entities, values
				(in particular collections and components) <emphasis>are</emphasis>
				persisted and deleted by reachability. Since value objects (and structs) are
				persisted and deleted along with their containing entity they may not be
				independently versioned. Values have no independent identity, so they cannot be
				shared by two entities or collections.
			</para>

			<para>
				All NHibernate types except collections support null semantics if the .NET type also
				supports it.
			</para>

			<para>
				Up until now, we've been using the term "persistent class" to refer to
				entities. We will continue to do that. Strictly speaking, however, not all
				user-defined classes with persistent state are entities. A
				<emphasis>component</emphasis> is a user defined class with value semantics.
			</para>
		</sect2>
		
		<sect2 id="mapping-types-basictypes">
			<title>Basic value types</title>

			<para>
				The <emphasis>basic types</emphasis> may be roughly categorized into three groups - <literal>System.ValueType</literal> 
				types, <literal>System.Object</literal> types, and <literal>System.Object</literal> types for large objects.  Just like
				the .NET Types, columns for System.ValueType types <emphasis>can not</emphasis> store <literal>null</literal> values 
				and System.Object types	<emphasis>can</emphasis> store <literal>null</literal> values.
			</para>
			<table>
				<title>System.ValueType Mapping Types</title>
				<tgroup cols="4">
					<thead>
						<row>
							<entry>NHibernate Type</entry>
							<entry>.NET Type</entry>
							<entry>Database Type</entry>
							<entry>Remarks</entry>	
						</row>
					</thead>	
					<tbody>
						<row>
							<entry><literal>Boolean</literal></entry>
							<entry><literal>System.Boolean</literal></entry>
							<entry><literal>DbType.Boolean</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Byte</literal></entry>
							<entry><literal>System.Byte</literal></entry>
							<entry><literal>DbType.Byte</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Char</literal></entry>
							<entry><literal>System.Char</literal></entry>
							<entry><literal>DbType.StringFixedLength - 1 char</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>DateTime</literal></entry>
							<entry><literal>System.DateTime</literal></entry>
							<entry><literal>DbType.DateTime</literal> - ignores the milliseconds</entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Decimal</literal></entry>
							<entry><literal>System.Decimal</literal></entry>
							<entry><literal>DbType.Decimal</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Double</literal></entry>
							<entry><literal>System.Double</literal></entry>
							<entry><literal>DbType.Double</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Guid</literal></entry>
							<entry><literal>System.Guid</literal></entry>
							<entry><literal>DbType.Guid</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Int16</literal></entry>
							<entry><literal>System.Int16</literal></entry>
							<entry><literal>DbType.Int16</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Int32</literal></entry>
							<entry><literal>System.Int32</literal></entry>
							<entry><literal>DbType.Int32</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Int64</literal></entry>
							<entry><literal>System.Int64</literal></entry>
							<entry><literal>DbType.Int64</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>PersistentEnum</literal></entry>
							<entry>A <literal>System.Enum</literal></entry>
							<entry>The <literal>DbType</literal> for the underlying value.</entry>
							<entry>Do not specify <literal>type="PersistentEnum"</literal> in the mapping.  Instead 
							specify the Assembly Qualified Name of the Enum or let NHibernate use Reflection to "guess" the Type.  
							The UnderlyingType of the Enum is used to determine the correct <literal>DbType</literal>.</entry>
						</row>
						<row>
							<entry><literal>Single</literal></entry>
							<entry><literal>System.Single</literal></entry>
							<entry><literal>DbType.Single</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Ticks</literal></entry>
							<entry><literal>System.DateTime</literal></entry>
							<entry><literal>DbType.Int64</literal></entry>
							<entry><literal>type="Ticks"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>TimeSpan</literal></entry>
							<entry><literal>System.TimeSpan</literal></entry>
							<entry><literal>DbType.Int64</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Timestamp</literal></entry>
							<entry><literal>System.DateTime</literal></entry>
							<entry><literal>DbType.DateTime</literal> - as specific as database supports.</entry>
							<entry><literal>type="Timestamp"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>TrueFalse</literal></entry>
							<entry><literal>System.Boolean</literal></entry>
							<entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'T' or 'F'</entry>
							<entry><literal>type="TrueFalse"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>YesNo</literal></entry>
							<entry><literal>System.Boolean</literal></entry>
							<entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'Y' or 'N'</entry>
							<entry><literal>type="YesNo"</literal> must be specified.</entry>
						</row>
					</tbody>
				</tgroup>	
			</table>
			
			<table>
				<title>System.Object Mapping Types</title>
				<tgroup cols="4">
					<thead>
						<row>
							<entry>NHibernate Type</entry>
							<entry>.NET Type</entry>
							<entry>Database Type</entry>
							<entry>Remarks</entry>	
						</row>
					</thead>	
					<tbody>
						<row>
							<entry><literal>AnsiString</literal></entry>
							<entry><literal>System.String</literal></entry>
							<entry><literal>DbType.AnsiString</literal></entry>
							<entry><literal>type="AnsiString"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>CultureInfo</literal></entry>
							<entry><literal>System.Globalization.CultureInfo</literal></entry>
							<entry><literal>DbType.String</literal> - 5 chars for culture</entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Binary</literal></entry>
							<entry><literal>System.Byte[]</literal></entry>
							<entry><literal>DbType.Binary</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Type</literal></entry>
							<entry><literal>System.Type</literal></entry>
							<entry><literal>DbType.String</literal> holding Assembly Qualified Name.</entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>String</literal></entry>
							<entry><literal>System.String</literal></entry>
							<entry><literal>DbType.String</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>	
			
			<table>
				<title>Large Object Mapping Types</title>
				<tgroup cols="4">
					<thead>
						<row>
							<entry>NHibernate Type</entry>
							<entry>.NET Type</entry>
							<entry>Database Type</entry>	
							<entry>Remarks</entry>
						</row>
					</thead>	
					<tbody>
						<row>
							<entry><literal>StringClob</literal></entry>
							<entry><literal>System.String</literal></entry>
							<entry><literal>DbType.String</literal></entry>
							<entry><literal>type="StringClob"</literal> must be specified.  Entire field is read into memory.</entry>
						</row>
						<row>
							<entry><literal>BinaryBlob</literal></entry>
							<entry><literal>System.Byte[]</literal></entry>
							<entry><literal>DbType.Binary</literal></entry>
							<entry><literal>type="BinaryBlob"</literal> must be specified.  Entire field is read into memory.</entry>
						</row>
						<row>
							<entry><literal>Serializable</literal></entry>
							<entry>Any <literal>System.Object</literal> that is marked with SerializableAttribute.</entry>
							<entry><literal>DbType.Binary</literal></entry>
							<entry><literal>type="Serializable"</literal> should be specified.  This is the fallback type
							if no NHibernate Type can be found for the Property.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>	
			
			<para>
				For those of you coming over from Hibernate or using some of the tools to generate <literal>hbm.xml</literal> files
				that are intended for Hibernate, there is a Hibernate compatiblity layer for type names.  A <literal>type="integer"</literal>
				will map to an <literal>Int32</literal> NHibernateType, <literal>type="short"</literal> to an <literal>Int16</literal>
				NHibernateType.  To see all of the conversions you can view the source of static constructor of the class 
				<literal>NHibernate.Type.TypeFactory</literal>. 
			</para>
		</sect2>
	        
	</sect1>	

	
	<sect1 id="mapping-quotedidentifiers">
			<title>SQL quoted identifiers</title>
			<para>
				You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
				column name in backticks in the mapping document.  NHibernate will use the correct quotation
				style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL
				Server and backticks for MySQL).
			</para>

			<programlisting><![CDATA[
<class name="LineItem" table="`Line Item`">
    <id name="id" column="`Item Id`">
        <generator class="assigned"/>
    </id>
    <property name="itemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>

    </sect1>

</chapter>