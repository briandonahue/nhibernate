<chapter id="mapping">
	<title>Basic O/R Mapping</title>

	<sect1 id="mapping-declaration">
		<title>Mapping declaration</title>

		<para>
			Object/relational mappings are defined in an XML document. The mapping document
			is designed to be readable and hand-editable. The mapping language is .NET-centric,
			meaning that mappings are constructed around persistent class declarations, not
			table declarations.
		</para>
	
		<para>
			Note that, even though many Hibernate users choose to define XML mappings be hand,
			a number of tools exist to generate the mapping document, including XDoclet,
			Middlegen and AndroMDA.
		</para>

		<para>
			Lets kick off with an example mapping:
		</para>

		<programlisting><![CDATA[
<?xml version="1.0" ?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.0">

        <class name="Eg.Cat, Eg" table="CATS" discriminator-value="C">
                <id name="Id" column="uid" type="Int64">
                        <generator class="hilo"/>
                </id>
                <discriminator column="subclass" type="Char"/>
                <property name="Birthdate" type="Date"/>
                <property name="Color" not-null="true"/>
                <property name="Sex" not-null="true" update="false"/>
                <property name="Weight"/>
                <many-to-one name="Mate" column="mate_id"/>
                <set name="Kittens">
                        <key column="mother_id"/>
                        <one-to-many class="Eg.Cat, Eg"/>
                </set>
                <subclass name="Eg.DomesticCat, Eg" discriminator-value="D">
                        <property name="Name" type="String"/>
                </subclass>
        </class>

        <class name="Eg.Dog, Eg">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>
]]></programlisting>

		<para>
				We will now discuss the content of the mapping document. We will only describe the 
				document elements and attributes that are used by Hibernate at runtime. The mapping 
				document also contains some extra optional attributes and elements that affect the 
				database schemas exported by the schema export tool. (For example the <literal>
				not-null</literal> attribute.)
		</para>

		<sect2 id="mapping-declaration-doctype">
			<title>Schema</title>

			<para>
				All XML mappings have to use the nhibernate-mapping-2.0 schema. The actual schema may be found 
				in the NHibernate source directory, or as an Embedded Resource in <literal>NHibernate.dll</literal>. 
				NHibernate will always use the Embedded Resource as the source for the schema.
			</para>
			
			<para>
				To get intellisense while working with the <literal>hibernate-mapping</literal> xml inside of VisualStudio.NET 
				you should copy the schema to the folder 
				<literal>C:\Program Files\Microsoft Visual Studio .NET 2003\Common7\Packages\schemas\xml</literal>
			</para>
		</sect2>

		<sect2 id="mapping-declaration-mapping">
			<title>hibernate-mapping</title>

			<para>
				This element has four optional attributes. The <literal>schema</literal> attribute
				specifies that tables referred to by this mapping belong to the named schema. If specified, 
				tablenames will be qualified by the given schema name. If missing, tablenames will be 
				unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style
				should be assumed for properties and collections which do not specify a 
				<literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us
				use unqualified class names in the query language, by default.  The <literal>default-access</literal>
				attribute tells us how to access property values.
			</para>
 
			<programlistingco>

				<programlisting>
&lt;hibernate-mapping
         schema="schemaName" <co id="hm1-co" linkends="hm1" />
         default-cascade="none|save-update" <co id="hm2-co" linkends="hm2" />
         auto-import="true|false" <co id="hm3-co" linkends="hm3" />
         default-access="property|field|nosetter|ClassName" <co id="hm4-co" linkends="hm4" />
 &gt;
				</programlisting>
				<calloutlist>
						<callout arearefs="hm1-co" id="hm1">
							<para>
								<literal>schema</literal> (optional): The name of a database schema.
							</para>
						</callout>
	
						<callout arearefs="hm2-co" id="hm2">
							<para>
								<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): 
								A default cascade style.
							</para>
						</callout>
	
						<callout arearefs="hm3-co" id="hm3">
							<para>
								<literal>auto-import</literal> (optional - defaults to <literal>true</literal>):
								Specifies whether we can use unqualified class names (of classes in this mapping)
								in the query language.
							</para>
						</callout>
						<callout arearefs="hm4-co" id="hm4">
							<para>
								<literal>default-access</literal> (optional - defaults to <literal>property</literal>):
								The strategy NHibernate should use for accessing the property value.
							</para>
						</callout>
						
					</calloutlist>
			</programlistingco>
			
			<para>
				If you have two persistent classes with the same (unqualified) name, you should set 
				<literal>auto-import="false"</literal>. NHibernate will throw an exception if you attempt
				to assign two classes to the same "imported" name.
			</para>
	
		</sect2>
		<sect2 id="mapping-declaration-class">
			<title>class</title>

			<para>
				You may declare a persistent class using the <literal>class</literal> element:
			</para>
	        
			<programlistingco>
				
                <programlisting>&lt;class
        name="ClassName" <co id="class1-co" linkends="class1" />
        table="tableName"<co id="class2-co" linkends="class2" />
        discriminator-value="discriminator_value"<co id="class3-co" linkends="class3" />
        mutable="true|false"<co id="class4-co" linkends="class4" />
        schema="owner"<co id="class5-co" linkends="class5" />
        proxy="ProxyInterface"<co id="class6-co" linkends="class6" />
        dynamic-update="true|false"<co id="class7-co" linkends="class7" />
        dynamic-insert="true|false"<co id="class8-co" linkends="class8" />
        polymorphism="implicit|explicit"<co id="class9-co" linkends="class9" />
        where="arbitrary sql where condition"<co id="class10-co" linkends="class10" />
        persister="PersisterClass"<co id="class11-co" linkends="class11" />
/&gt;</programlisting>
				<calloutlist>
					<callout arearefs="class1-co" id="class1">
						<para>
							<literal>name</literal>: The fully qualified .NET Type name of the persistent class 
							(or interface).
						</para>
					</callout>
					<callout arearefs="class2-co" id="class2">
						<para>
							<literal>table</literal>: The name of its database table.
						</para>
					</callout>
					<callout arearefs="class3-co" id="class3">
						<para>
							<literal>discriminator-value</literal> (optional - defaults to the class name): A value
							that distiguishes individual subclasses, used for polymorphic behaviour.
						</para>
					</callout>
					<callout arearefs="class4-co" id="class4">
						<para>
							<literal>mutable</literal> (optional, defaults to <literal>true</literal>): Specifies 
							that instances of the class are (not) mutable.
						</para>
					</callout>    
					<callout arearefs="class5-co" id="class5">
						<para>
							<literal>schema</literal> (optional): Override the schema name specified by
							the root <literal>&lt;hibernate-mapping&gt;</literal> element.
						</para>
					</callout>                
					<callout arearefs="class6-co" id="class6">
						<para>
							<literal>proxy</literal> (optional): Specifies an interface to use for lazy
							initializing proxies. You may specify the name of the class itself as long as 
							all Properties are virtual.
						</para>
					</callout>    
					<callout arearefs="class7-co" id="class7">
						<para>
							<literal>dynamic-update</literal> (optional, defaults to <literal>false</literal>): 
							Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and 
							contain only those columns whose values have changed.
						</para>
					</callout>    
					<callout arearefs="class8-co" id="class8">
						<para>
							<literal>dynamic-insert</literal> (optional, defaults to <literal>false</literal>): 
							Specifies that <literal>INSERT</literal> SQL should be generated at runtime and 
							contain only the columns whose values are not null.
						</para>
					</callout>    
					<callout arearefs="class9-co" id="class9">
						<para>
							<literal>polymorphism</literal> (optional, defaults to <literal>implicit</literal>): 
							Determines whether implicit or explicit query polymorphism is used.
						</para>
					</callout>    
					<callout arearefs="class10-co" id="class10">
						<para>
							<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> 
							condition to be used when retrieving objects of this class
						</para>
					</callout>                 
					<callout arearefs="class11-co" id="class11">
						<para>
							<literal>persister</literal> (optional): Specifies a custom <literal>IClassPersister</literal>.
						</para>
					</callout>                 
				</calloutlist>
			</programlistingco>
	
			<para>
				It is perfectly acceptable for the named persistent class to be an interface. You would then
				declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal>
				element. You may persist any inner class. You should specify the
				class name using the standard form ie. <literal>Eg.Foo+Bar</literal>.
			</para>

			<para>
				Immutable classes, <literal>mutable="false"</literal>, may not be updated or deleted by the 
				application. This allows NHibernate to make some minor performance optimizations.
			</para>
	        
			<para>
				The optional <literal>proxy</literal> attribute enables lazy initialization of persistent
				instances of the class. NHibernate will initially return Aspect# proxies which implement 
				the named interface. The actual persistent object will be loaded when a method of the 
				proxy is invoked. See "Proxies for Lazy Initialization" below.
			</para>
	        
			<para><emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned
				by a query that names any superclass or implemented interface or the class and that instances
				of any subclass of the class will be returned by a query that names the class itself. 
				<emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only
				be queries that explicitly name that class and that queries that name the class will return
				only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration
				as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For
				most purposes the default, <literal>polymorphism="implicit"</literal>, is appropriate.
				Explicit polymorphism is useful when two different classes are mapped to the same table
				(this allows a "lightweight" class that contains a subset of the table columns).
			</para>
	        
			<para>
				The <literal>persister</literal> attribute lets you customize the persistence strategy used for
				the class. You may, for example, specify your own subclass of 
				<literal>NHibernate.Persister.EntityPersister</literal> or you might even provide a
				completely new implementation of the interface 
				<literal>NHibernate.Persister.IClassPersister</literal> that implements persistence via,
				for example, stored procedure calls, serialization to flat files or LDAP. See
				<literal>NHibernate.DomainModel.CustomPersister</literal> for a simple example (of "persistence"
				to a <literal>Hashtable</literal>).
			</para>
	        
			<para>
				Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal>
				settings are not inherited by subclasses and so may also be specified on the
				<literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements. 
				These settings may increase performance in some cases, but might actually decrease 
				performance in others. Use judiciously.
			</para>
	        
		</sect2>

		<sect2 id="mapping-declaration_id">
			<title>id</title>

			<para>
				Mapped classes <emphasis>must</emphasis> declare the primary key column of the database 
				table. Most classes will also have a Property holding the unique identifier 
				of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that
				property to the primary key column.
			</para>
	
			<programlistingco>
				<programlisting>&lt;id 
        name="propertyName" <co id="id1-co" linkends="id1" />
        type="typename" <co id="id2-co" linkends="id2" />
        column="column_name" <co id="id3-co" linkends="id3" />
        unsaved-value="any|none|null|id_value" <co id="id4-co" linkends="id4" />
        access="field|property|nosetter|ClassName"&gt; <co id="id5-co" linkends="id5" />

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;		</programlisting>
				<calloutlist>
					<callout arearefs="id1-co" id="id1">
						<para>
							<literal>name</literal> (optional): The name of the identifier property.
						</para>
					</callout>
					<callout arearefs="id2-co" id="id2">
						<para>
							<literal>type</literal> (optional): A name that indicates the NHibernate type.
						</para>
					</callout>
					<callout arearefs="id3-co" id="id3">
						<para>
							<literal>column</literal> (optional - defaults to the property name): The
							name of the primary key column.
						</para>
					</callout>
					<callout arearefs="id4-co" id="id4">
						<para>
							<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): 
							An identifier property value that indicates that an instance is newly instantiated
							(unsaved), distinguishing it from transient instances that were saved or loaded
							in a previous session.
						</para>
					</callout>            
					<callout arearefs="id5-co" id="id5">
						<para>
							<literal>access</literal> (optional - defaults to <literal>property</literal>): The
							strategy NHibernate should use for accessing the property value.
						</para>
					</callout>
				</calloutlist>
			</programlistingco>
			
			<para>
				If the <literal>name</literal> attribute is missing, it is assumed that the class has no 
				identifier property.
			</para>
	        
			<para>
				The <literal>unsaved-value</literal> attribute is important! If the identfier property of your 
				class does not default to <literal>null</literal>, then you should specify the actual default.
				This is especially important when using a <literal>System.ValueType</literal> such as 
				<literal>System.Int32</literal> or <literal>System.Guid</literal> as your <literal>&lt;id&gt;</literal>
				 property.  Make sure to explicity set this attribute because <literal>System.ValueType</literal> 
				objects can not be <literal>null</literal>.
			</para>

			<para>
				There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to
				legacy data with composite keys. We strongly discourage its use for anything else.
			</para>
	
		</sect2>
		
		<sect2 id="mapping-declaration-property">
			<title>property</title>

			<para>
				The <literal>&lt;property&gt;</literal> element declares a persistent, 
				property of the class.
			</para>
	        
			<programlistingco>
                <programlisting>&lt;property
        name="propertyName"<co id="property1-co" linkends="property1" />
        column="column_name"<co id="property2-co" linkends="property2" />
        type="typename"<co id="property3-co" linkends="property3" />
        update="true|false"<co id="property4-co" linkends="property4" />
        insert="true|false"<co id="property5-co" linkends="property5" />
        formula="arbitrary SQL expression"<co id="property6-co" linkends="property6" />
        access="field|property|nosetter|ClassName"<co id="property7-co" linkends="property7" />
/&gt;</programlisting>
				<calloutlist>
					<callout arearefs="property1-co" id="property1">
						<para>
							<literal>name</literal>: the name of the property in the same case as the Propery in your API
						</para>
					</callout>                   
					<callout arearefs="property2-co" id="property2">
						<para>
							<literal>column</literal> (optional - defaults to the property name): the name
							of the mapped database table column.
						</para>
					</callout>
					<callout arearefs="property3-co" id="property3">
						<para>
							<literal>type</literal> (optional): a name that indicates the NHibernate type.
						</para>
					</callout>
					<callout arearefs="property4-co" id="property4">
						<para>
							<literal>update</literal> (optional - defaults to <literal>true</literal>) :
							specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> 
						</para>
					</callout>
					<callout arearefs="property5-co" id="property5">
						<para>
							<literal>insert</literal> (optional - defaults to <literal>true</literal>) :
							specifies that the mapped columns should be included in SQL 
							<literal>INSERT</literal> statements. Setting both <literal>insert</literal>
							and <literal>update</literal> to <literal>false</literal>
							allows a pure "derived" property whose value is initialized from some other
							property that maps to the same colum(s) or by a trigger or other application.
						</para>
					</callout>
					<callout arearefs="property6-co" id="property6">
						<para>
							<literal>formula</literal> (optional): an SQL expression that defines the value for a
							<emphasis>computed</emphasis> property. Computed properties do not have a column
							mapping of their own.
						</para>
					</callout>
					<callout arearefs="property7-co" id="property7">
						<para>
							<literal>access</literal> (optional - defaults to <literal>property</literal>): The
							strategy NHibernate should use for accessing the property value.
						</para>
					</callout>
				</calloutlist>
			</programlistingco>

			<para>
				<emphasis>typename</emphasis> could be:
			</para>

			<orderedlist spacing="compact">
				<listitem>
					<para>
						The name of a NHibernate basic type (eg. <literal>Int32, String, Char,
						DateTime, Timstamp, Single, Byte[], Object, ...</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a .NET type with a default basic type (eg. <literal>System.Int16, System.Single,
						System.Char, System.String, System.DateTime, System.Byte[], ...</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a your of <literal>System.Enum </literal> (eg. <literal>Eg.Color</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a serializable .NET type.
					</para>
				</listitem>
				<listitem>
					<para>
						The type of a custom type (eg. <literal>Illflow.Type.MyCustomType, Illflow</literal>).
					</para>
				</listitem>
			</orderedlist>

			<para>
				If you do not specify a type, NHibernate will use reflection upon the named
				property to take a guess at the correct NHibernate type. NHibernate will try to
				interpret the name of the return class of the property getter using rules 2, 3,
				4 in that order. However, this is not always enough.
				In certain cases you will still need the <literal>type</literal>
				attribute. (For example, to distinguish between <literal>NHibernate.DateTime</literal> and
				<literal>NHibernate.Timestamp</literal>, or to specify a custom type.)
			</para>
			
			<para>
				The <literal>access</literal> attribute lets you control how NHibernate will access
				the value of the property at runtime.  The value of the <literal>access</literal> attribute should
				be text formatted as <literal>access-strategy.naming-strategy</literal>.  The 
				<literal>.naming-stragey</literal> is not always required.
				<variablelist>
					<title>Access Strategy</title>
					<varlistentry>
						<term><literal>property</literal></term>
						<listitem>
							<para>
								The default implementation.  NHibernate uses the get/set of your Property.  No
								Naming Strategy should be used with this Access Strategy because the 
								<literal>name</literal> attribute is the name of your Property.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>field</literal></term>
						<listitem>
							<para>
								NHibernate will access the Field directly.  NHibernate uses the <literal>&lt;name&gt;</literal>
								as the name of the field.  This can be used when a Property's get and set have extra
								actions in them that you don't want to occur when NHibernate is populating or reading the object.  
								If you want the name of the Property and not the Field to be what the consumers of your API 
								use with HQL, then a Naming Strategy is needed.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>nosetter</literal></term>
						<listitem>
							<para>
								NHibernate will access the Field directly when setting the value and will use the
								Property when getting the value.  This can be used when a Property only exposes a get because
								the consumers of your API can't change the value directly.  A Naming Strategy is required
								because NHibernate uses the <literal>name</literal> attribute as the Property so it needs to 
								be told what the name of the Field is.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>ClassName</literal></term>
						<listitem>
							<para>
								If NHibernate's built in Access Strategies are not what is needed for your situation
								then you can build your own by implementing the interface 
								<literal>NHibernate.Property.IPropertyAccessor</literal>.  The value of the 
								<literal>access</literal> attribute should be an Assembly Qualified Name that can be 
								loaded with <literal>Activator.CreateInstance(string AssemblyQualifiedName)</literal>.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
			
			<para>
				<variablelist>
					<title>Naming Strategy</title>
					<varlistentry>
						<term><literal>camelcase</literal></term>
						<listitem>
							<para>
								The <literal>name</literal> attribute is converted to CamelCase to find the Field.
								<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>foo</literal>.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>camelcase-underscore</literal></term>
						<listitem>
							<para>
								The <literal>name</literal> attribute is converted to CamelCase and prefixed with an
								underscore to find the Field.
								<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>_foo</literal>.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><literal>pascalcase-m-underscore</literal></term>
						<listitem>
							<para>
								The <literal>name</literal> attribute is prefixed with the character
								m and an underscore to find the Field.
								<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>m_Foo</literal>.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>
		</sect2>
	</sect1>

	
	<sect1 id="mapping-quotedidentifiers">
			<title>SQL quoted identifiers</title>
			<para>
				You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
				column name in backticks in the mapping document.  NHibernate will use the correct quotation
				style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL
				Server and backticks for MySQL).
			</para>

			<programlisting><![CDATA[
<class name="LineItem" table="`Line Item`">
    <id name="id" column="`Item Id`">
        <generator class="assigned"/>
    </id>
    <property name="itemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>

    </sect1>

</chapter>

