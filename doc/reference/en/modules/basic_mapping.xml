<!-- 
	before committing make sure to comment out the DOCTYPE
	It is in here to get intellisense with XMLSpy.  The
	HomeEdition is a free download.

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "../../support/docbook-dtd/docbookx.dtd">
-->
<chapter id="mapping">
	<title>Basic O/R Mapping</title>

	<sect1 id="mapping-declaration">
		<title>Mapping declaration</title>

		<para>
			Object/relational mappings are defined in an XML document. The mapping document
			is designed to be readable and hand-editable. The mapping language is .NET-centric,
			meaning that mappings are constructed around persistent class declarations, not
			table declarations.
		</para>
	
		<para>
			Note that, even though many Hibernate users choose to define XML mappings be hand,
			a number of tools exist to generate the mapping document, including XDoclet,
			Middlegen and AndroMDA.
		</para>

		<para>
			Lets kick off with an example mapping:
		</para>

		<programlisting><![CDATA[
<?xml version="1.0" ?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.0">

	<class name="Eg.Cat, Eg" table="CATS" discriminator-value="C">
		<id name="Id" column="uid" type="Int64">
			<generator class="hilo"/>
		</id>
		<discriminator column="subclass" type="Char"/>
		<property name="Birthdate" type="Date"/>
		<property name="Color" not-null="true"/>
		<property name="Sex" not-null="true" update="false"/>
		<property name="Weight"/>
		<many-to-one name="Mate" column="mate_id"/>
		<set name="Kittens">
			<key column="mother_id"/>
			<one-to-many class="Eg.Cat, Eg"/>
		</set>
		<subclass name="Eg.DomesticCat, Eg" discriminator-value="D">
			<property name="Name" type="String"/>
		</subclass>
	</class>

	<class name="Eg.Dog, Eg">
		<!-- mapping for Dog could go here -->
	</class>

</hibernate-mapping>
]]></programlisting>

		<para>
				We will now discuss the content of the mapping document. We will only describe the 
				document elements and attributes that are used by Hibernate at runtime. The mapping 
				document also contains some extra optional attributes and elements that affect the 
				database schemas exported by the schema export tool. (For example the <literal>
				not-null</literal> attribute.)
		</para>

		<sect2 id="mapping-declaration-doctype">
			<title>Schema</title>

			<para>
				All XML mappings have to use the nhibernate-mapping-2.0 schema. The actual schema may be found 
				in the NHibernate source directory, or as an Embedded Resource in <literal>NHibernate.dll</literal>. 
				NHibernate will always use the Embedded Resource as the source for the schema.
			</para>
			
			<para>
				To get intellisense while working with the <literal>hibernate-mapping</literal> xml inside of VisualStudio.NET 
				you should copy the schema to the folder 
				<literal>C:\Program Files\Microsoft Visual Studio .NET 2003\Common7\Packages\schemas\xml</literal>
			</para>
		</sect2>

		<sect2 id="mapping-declaration-mapping">
			<title>hibernate-mapping</title>

			<para>
				This element has four optional attributes. The <literal>schema</literal> attribute
				specifies that tables referred to by this mapping belong to the named schema. If specified, 
				tablenames will be qualified by the given schema name. If missing, tablenames will be 
				unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style
				should be assumed for properties and collections which do not specify a 
				<literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us
				use unqualified class names in the query language, by default.  The <literal>default-access</literal>
				attribute tells us how to access property values.
			</para>
 
			
			<programlisting>&lt;hibernate-mapping
	schema="schemaName" <co id="hm1-co" linkends="hm1" />
	default-cascade="none|save-update" <co id="hm2-co" linkends="hm2" />
	auto-import="true|false" <co id="hm3-co" linkends="hm3" />
	default-access="property|field|nosetter|ClassName" <co id="hm4-co" linkends="hm4" />
&gt; </programlisting>
			<calloutlist>
					<callout arearefs="hm1-co" id="hm1">
						<para>
							<literal>schema</literal> (optional): The name of a database schema.
						</para>
					</callout>
	
					<callout arearefs="hm2-co" id="hm2">
						<para>
							<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): 
							A default cascade style.
						</para>
					</callout>
	
					<callout arearefs="hm3-co" id="hm3">
						<para>
							<literal>auto-import</literal> (optional - defaults to <literal>true</literal>):
							Specifies whether we can use unqualified class names (of classes in this mapping)
							in the query language.
						</para>
					</callout>
					<callout arearefs="hm4-co" id="hm4">
						<para>
							<literal>default-access</literal> (optional - defaults to <literal>property</literal>):
							The strategy NHibernate should use for accessing the property value.
						</para>
					</callout>
					
				</calloutlist>
			
			<para>
				If you have two persistent classes with the same (unqualified) name, you should set 
				<literal>auto-import="false"</literal>. NHibernate will throw an exception if you attempt
				to assign two classes to the same "imported" name.
			</para>
	
		</sect2>
		<sect2 id="mapping-declaration-class">
			<title>class</title>

			<para>
				You may declare a persistent class using the <literal>class</literal> element:
			</para>
	        
			
				
			<programlisting>&lt;class
	name="ClassName" <co id="class1-co" linkends="class1" />
	table="tableName"<co id="class2-co" linkends="class2" />
	discriminator-value="discriminator_value"<co id="class3-co" linkends="class3" />
	mutable="true|false"<co id="class4-co" linkends="class4" />
	schema="owner"<co id="class5-co" linkends="class5" />
	proxy="ProxyInterface"<co id="class6-co" linkends="class6" />
	dynamic-update="true|false"<co id="class7-co" linkends="class7" />
	dynamic-insert="true|false"<co id="class8-co" linkends="class8" />
	polymorphism="implicit|explicit"<co id="class9-co" linkends="class9" />
	where="arbitrary sql where condition"<co id="class10-co" linkends="class10" />
	persister="PersisterClass"<co id="class11-co" linkends="class11" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="class1-co" id="class1">
					<para>
						<literal>name</literal>: The fully qualified .NET Type name of the persistent class 
						(or interface).
					</para>
				</callout>
				<callout arearefs="class2-co" id="class2">
					<para>
						<literal>table</literal>: The name of its database table.
					</para>
				</callout>
				<callout arearefs="class3-co" id="class3">
					<para>
						<literal>discriminator-value</literal> (optional - defaults to the class name): A value
						that distiguishes individual subclasses, used for polymorphic behaviour.
					</para>
				</callout>
				<callout arearefs="class4-co" id="class4">
					<para>
						<literal>mutable</literal> (optional, defaults to <literal>true</literal>): Specifies 
						that instances of the class are (not) mutable.
					</para>
				</callout>    
				<callout arearefs="class5-co" id="class5">
					<para>
						<literal>schema</literal> (optional): Override the schema name specified by
						the root <literal>&lt;hibernate-mapping&gt;</literal> element.
					</para>
				</callout>                
				<callout arearefs="class6-co" id="class6">
					<para>
						<literal>proxy</literal> (optional): Specifies an interface to use for lazy
						initializing proxies. You may specify the name of the class itself as long as 
						all Properties are virtual.
					</para>
				</callout>    
				<callout arearefs="class7-co" id="class7">
					<para>
						<literal>dynamic-update</literal> (optional, defaults to <literal>false</literal>): 
						Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and 
						contain only those columns whose values have changed.
					</para>
				</callout>    
				<callout arearefs="class8-co" id="class8">
					<para>
						<literal>dynamic-insert</literal> (optional, defaults to <literal>false</literal>): 
						Specifies that <literal>INSERT</literal> SQL should be generated at runtime and 
						contain only the columns whose values are not null.
					</para>
				</callout>    
				<callout arearefs="class9-co" id="class9">
					<para>
						<literal>polymorphism</literal> (optional, defaults to <literal>implicit</literal>): 
						Determines whether implicit or explicit query polymorphism is used.
					</para>
				</callout>    
				<callout arearefs="class10-co" id="class10">
					<para>
						<literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal> 
						condition to be used when retrieving objects of this class
					</para>
				</callout>                 
				<callout arearefs="class11-co" id="class11">
					<para>
						<literal>persister</literal> (optional): Specifies a custom <literal>IClassPersister</literal>.
					</para>
				</callout>                 
			</calloutlist>
	
			<para>
				It is perfectly acceptable for the named persistent class to be an interface. You would then
				declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal>
				element. You may persist any inner class. You should specify the
				class name using the standard form ie. <literal>Eg.Foo+Bar</literal>.
			</para>

			<para>
				Immutable classes, <literal>mutable="false"</literal>, may not be updated or deleted by the 
				application. This allows NHibernate to make some minor performance optimizations.
			</para>
	        
			<para>
				The optional <literal>proxy</literal> attribute enables lazy initialization of persistent
				instances of the class. NHibernate will initially return proxies generated by Castle.DynamicProxy
				which implement the named interface or extend the class. The actual persistent object will be 
				loaded when a method of the proxy is invoked. See "Proxies for Lazy Initialization" below.
			</para>
	        
			<para><emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned
				by a query that names any superclass or implemented interface or the class and that instances
				of any subclass of the class will be returned by a query that names the class itself. 
				<emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only
				be queries that explicitly name that class and that queries that name the class will return
				only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration
				as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For
				most purposes the default, <literal>polymorphism="implicit"</literal>, is appropriate.
				Explicit polymorphism is useful when two different classes are mapped to the same table
				(this allows a "lightweight" class that contains a subset of the table columns).
			</para>
	        
			<para>
				The <literal>persister</literal> attribute lets you customize the persistence strategy used for
				the class. You may, for example, specify your own subclass of 
				<literal>NHibernate.Persister.EntityPersister</literal> or you might even provide a
				completely new implementation of the interface 
				<literal>NHibernate.Persister.IClassPersister</literal> that implements persistence via,
				for example, stored procedure calls, serialization to flat files or LDAP. See
				<literal>NHibernate.DomainModel.CustomPersister</literal> for a simple example (of "persistence"
				to a <literal>Hashtable</literal>).
			</para>
	        
			<para>
				Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal>
				settings are not inherited by subclasses and so may also be specified on the
				<literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements. 
				These settings may increase performance in some cases, but might actually decrease 
				performance in others. Use judiciously.
			</para>
	        
		</sect2>

		<sect2 id="mapping-declaration_id">
			<title>id</title>

			<para>
				Mapped classes <emphasis>must</emphasis> declare the primary key column of the database 
				table. Most classes will also have a Property holding the unique identifier 
				of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that
				property to the primary key column.
			</para>
	
			<programlisting>&lt;id 
	name="propertyName" <co id="id1-co" linkends="id1" />
	type="typename" <co id="id2-co" linkends="id2" />
	column="column_name" <co id="id3-co" linkends="id3" />
	unsaved-value="any|none|null|id_value" <co id="id4-co" linkends="id4" />
	access="field|property|nosetter|ClassName"&gt; <co id="id5-co" linkends="id5" />

	&lt;generator class="generatorClass"/&gt;
&lt;/id&gt;		</programlisting>
			<calloutlist>
				<callout arearefs="id1-co" id="id1">
					<para>
						<literal>name</literal> (optional): The name of the identifier property.
					</para>
				</callout>
				<callout arearefs="id2-co" id="id2">
					<para>
						<literal>type</literal> (optional): A name that indicates the NHibernate type.
					</para>
				</callout>
				<callout arearefs="id3-co" id="id3">
					<para>
						<literal>column</literal> (optional - defaults to the property name): The
						name of the primary key column.
					</para>
				</callout>
				<callout arearefs="id4-co" id="id4">
					<para>
						<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): 
						An identifier property value that indicates that an instance is newly instantiated
						(unsaved), distinguishing it from transient instances that were saved or loaded
						in a previous session.
					</para>
				</callout>            
				<callout arearefs="id5-co" id="id5">
					<para>
						<literal>access</literal> (optional - defaults to <literal>property</literal>): The
						strategy NHibernate should use for accessing the property value.
					</para>
				</callout>
			</calloutlist>
			
			
			<para>
				If the <literal>name</literal> attribute is missing, it is assumed that the class has no 
				identifier property.
			</para>
	        
			<para>
				The <literal>unsaved-value</literal> attribute is important! If the identfier property of your 
				class does not default to <literal>null</literal>, then you should specify the actual default.
				This is especially important when using a <literal>System.ValueType</literal> such as 
				<literal>System.Int32</literal> or <literal>System.Guid</literal> as your <literal>&lt;id&gt;</literal>
				 property.  Make sure to explicity set this attribute because <literal>System.ValueType</literal> 
				objects can not be <literal>null</literal>.
			</para>

			<para>
				There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to
				legacy data with composite keys. We strongly discourage its use for anything else.
			</para>
			
			<sect3 id="mapping-declaration-id-generator">
				<title>generator</title>

				<para>
					The required <literal>&lt;generator&gt;</literal> child element names a .NET type used
					to generate unique identifiers for instances of the persistent class. If any parameters
					are required to configure or initialize the generator instance, they are passed using the
					<literal>&lt;param&gt;</literal> element.
				</para>

				<programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0">
	<generator class="NHibernate.Id.TableHiLoGenerator">
		<param name="table">uid_table</param>
		<param name="column">next_hi_value_column</param>
	</generator>
</id>]]></programlisting>

				<para>
					All generators implement the interface <literal>NHibernate.Id.IdentifierGenerator</literal>.
					This is a very simple interface; some applications may choose to provide their own specialized
					implementations. However, NHibernate provides a range of built-in implementations. There are shortcut
					names for the built-in generators:
	                
					<variablelist>
						<varlistentry>
						<term><literal>identity</literal></term>
						<listitem>
							<para>
								supports identity columns in DB2, MySQL, MS SQL Server, Sybase and
								HypersonicSQL. The returned identifier is of type <literal>Int64</literal>,
								<literal>Int32</literal> or <literal>Int16</literal>.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>sequence</literal></term>
						<listitem>
							<para>
								uses a sequence in DB2, PostgreSQL, Oracle. The returned identifier 
								is of type <literal>Int64</literal>,
								<literal>Int32</literal> or <literal>Int16</literal>
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>hilo</literal></term>
						<listitem>
							<para>
								uses a hi/lo algorithm to efficiently generate identifiers of
								type <literal>Int64</literal>, <literal>Int32</literal> or <literal>Int16</literal>,
								given a table and column (by default <literal>hibernate_unique_key</literal> and
								<literal>next</literal> respectively) as a source of hi values. The hi/lo algorithm
								generates identifiers that are unique only for a particular database.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>seqhilo</literal></term>
						<listitem>
							<para>
								uses a hi/lo algorithm to efficiently generate identifiers of type
								<literal>Int64</literal>, <literal>Int32</literal> or <literal>Int16</literal>,
								given a named database sequence.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>uuid.hex</literal></term>
						<listitem>
							<para>
								uses <literal>System.Guid</literal> and its <literal>ToString(string format)</literal> method
								to generate identifiers of type string.  The length of the string returned depends on the 
								configured <literal>format</literal>.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>uuid.string</literal></term>
						<listitem>
							<para>
								uses a new <literal>System.Guid</literal> to create a <literal>byte[]</literal> that is
								converted to a string.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>guid</literal></term>
						<listitem>
							<para>
								uses a new <literal>System.Guid</literal> as the identifier.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>guid.comb</literal></term>
						<listitem>
							<para>
								uses the algorithm to generate a new <literal>System.Guid</literal>
								described by Jimmy Nilsson in the article 
								http://www.informit.com/articles/article.asp?p=25862.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>native</literal></term>
						<listitem>
							<para>
								picks <literal>identity</literal>, <literal>sequence</literal> or
								<literal>hilo</literal> depending upon the capabilities of the
								underlying database.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>assigned</literal></term>
						<listitem>
							<para>
								lets the application to assign an identifier to the object before
								<literal>save()</literal> is called.
							</para>
						</listitem>
						</varlistentry>
						<varlistentry>
						<term><literal>foreign</literal></term>
						<listitem>
							<para>
								uses the identifier of another associated object. Usually used in conjunction
								with a <literal>&lt;one-to-one&gt;</literal> primary key association.
							</para>
						</listitem>
						</varlistentry>
					</variablelist>

				</para>
			</sect3>
	        
	        
			<sect3 id="mapping-declaration-id-hilo">
				<title>Hi/Lo Algorithm</title>
				<para>
					The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate
					implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
					first implementation requires a "special" database table to hold the next available "hi" value.
					The second uses an Oracle-style sequence (where supported).
				</para>

				<programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
	<generator class="hilo">
		<param name="table">hi_value</param>
		<param name="column">next_value</param>
		<param name="max_lo">100</param>
	</generator>
</id>]]></programlisting>

				<programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
	<generator class="seqhilo">
		<param name="sequence">hi_value</param>
		<param name="max_lo">100</param>
	</generator>
</id>]]></programlisting>

				<para>
					Unfortunately, you can't use <literal>hilo</literal> when supplying your own
					<literal>Connection</literal>  to NHibernate. NHibernate must be able to
					fetch the "hi" value in a new transaction.
				</para>
			</sect3>
	        
			<sect3 id="mapping-declaration-id-uuid-hex">
				<title>UUID Hex Algorithm</title>

				<programlisting><![CDATA[<id name="Id" type="String" column="cat_id">
	<generator class="uuid.hex">
		<param name="format">format_value</param>
		<param name="seperator">seperator_value</param>
	</generator>
</id>]]></programlisting>

				<para>
					The UUID is generated by calling <literal>Guid.NewGuid().ToString(format)</literal>.  The
					valid values for format are described in the MSDN documentation.  The default 
					<literal>seperator</literal> is <literal>-</literal> and should rarely be modified.  The
					<literal>format</literal> determines if the configured <literal>seperator</literal> can 
					replace the default seperator used by the <literal>format</literal>.
				</para>
			</sect3>
	        
			<sect3 id="mapping-declaration-id-uuid-string">
				<title>UUID String Algorithm</title>
				<para>
					The UUID is generated by calling <literal>Guid.NewGuid().ToByteArray()</literal> and 
					then converting the <literal>byte[]</literal> into a <literal>char[]</literal>.  The
					<literal>char[]</literal> is returned as a <literal>String</literal> consisting of
					16 characters.
				</para>
			</sect3>

			<sect3 id="mapping-declaration-id-guid">
				<title>GUID Algorithms</title>
				<para>
					The <literal>guid</literal> identifier is generated by calling <literal>Guid.NewGuid()</literal>.
					To address some of the performance concerns with using Guids as primary keys, foreign keys, and
					as part of indexes with MS SQL the <literal>guid.comb</literal> can be used.  The benefit of using  
					the <literal>guid.comb</literal> with other databases that support GUIDs has not been measured.
				</para>
			</sect3>

			<sect3 id="mapping-declaration-id-sequences">
				<title>Identity columns and Sequences</title>
				<para>
					For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
					may use <literal>identity</literal> key generation. For databases that support
					sequences (DB2, Oracle, PostgreSQL) you may use
					<literal>sequence</literal> style key generation. Both these strategies usually require
					two SQL queries to insert a new object.  When working with MS SQL and the 
					<literal>identity</literal> key generator then <literal>select SCOPE_IDENTITY()</literal>
					will be appended to the <literal>insert</literal> sql thus avoiding the executions
					of a two distinct <literal>IDbCommand</literal>s.
				</para>

				<programlisting><![CDATA[<id name="Id" type="Int64" column="uid">
	<generator class="sequence">
			<param name="sequence">uid_sequence</param>
	</generator>
</id>]]></programlisting>

				<programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0">
	<generator class="identity"/>
</id>]]></programlisting>
	        
				<para>
					For cross-platform development, the <literal>native</literal> strategy will
					choose from the <literal>identity</literal>, <literal>sequence</literal> and
					<literal>hilo</literal> strategies, dependant upon the capabilities of the
					underlying database.
				</para>
			</sect3>
	        
			<sect3 id="mapping-declaration-id-assigned">
				<title>Assigned Identifiers</title>
				<para>
					If you want the application to assign identifiers (as opposed to having
					NHibernate generate them), you may use the <literal>assigned</literal> generator.
					This special generator will use the identifier value already assigned to the
					object's identifier property. Be very careful when using this feature to not assign
					keys with business meaning (almost always a terrible design decision).
				</para>
				<para>
					Due to its inherent nature, entities that use this generator cannot be saved
					via the ISession's <literal>SaveOrUpdate()</literal> method. Instead you have to 
					explicitly specify to NHibernate if the object should be saved or updated 
					by calling either the <literal>Save()</literal> or <literal>Update()</literal> 
					method of the ISession.
				</para>
			</sect3>
		</sect2>
		
		<sect2 id="mapping-declaration-compositeid">
			<title>composite-id</title>

			<programlisting>&lt;composite-id
	name="propertyName"<co id="composite-id1-co" linkends="composite-id1" />
	class="ClassName"<co id="composite-id2-co" linkends="composite-id2" />
	unsaved-value="any|none"<co id="composite-id3-co" linkends="composite-id3" />
	access="field|property|nosetter|ClassName"&gt;

	&lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
	&lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
	......
&lt;/composite-id&gt;</programlisting>

			<para>
				For a table with a composite key, you may map multiple properties of the class
				as identifier properties. The <literal>&lt;composite-id&gt;</literal> element
				accepts <literal>&lt;key-property&gt;</literal> property mappings and
				<literal>&lt;key-many-to-one&gt;</literal> mappings as child elements.
			</para>

			<programlisting><![CDATA[<composite-id>
	<key-property name="medicareNumber"/>
	<key-property name="dependent"/>
</composite-id>]]></programlisting>

			<para>
				Your persistent class <emphasis>must</emphasis> override <literal>Equals()</literal>
				and <literal>GetHashCode()</literal> to implement composite identifier equality. It must
				also be <literal>Serializable</literal>.
			</para>

			<para>
				Unfortunately, this approach to composite identifiers means that a persistent object 
				is its own identifier. There is no convenient "handle" other than the object itself. 
				You must instantiate an instance of the persistent class itself and populate its 
				identifier properties before you can <literal>Load()</literal> the persistent state
				associated with a composite key. We will describe a much more
				convenient approach where the composite identifier is implemented as a seperate class
				in TODO:LINKTOCOMPENENTS<!--<xref linkend="components-compositeid"/>-->. The attributes described below apply only
				to this alternative approach:
			</para>
			
			<calloutlist>
				<callout arearefs="composite-id1-co" id="composite-id1">
					<para>
						<literal>name</literal> (optional): A property of component type that holds the
						composite identifier (see next section).
					</para>
				</callout>  
				<callout arearefs="composite-id2-co" id="composite-id2">
					<para>
						<literal>class</literal> (optional - defaults to the property type determined by 
						reflection): The component class used as a composite identifier (see next section).
					</para>
				</callout>  
				<callout arearefs="composite-id3-co" id="composite-id3">
					<para>
						<literal>unsaved-value</literal> (optional - defaults to <literal>none</literal>): 
						Indicates that transient instances should be considered newly instantiated, if set 
						to <literal>any</literal>.
					</para>
				</callout>  
			</calloutlist> 
	        
		</sect2>
	    
		<sect2 id="mapping-declaration-discriminator">
			<title>discriminator</title>

			<para>
				The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence 
				using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the 
				table. The discriminator column contains marker values that tell the persistence layer what 
				subclass to instantiate for a particular row. A restricted set of types may be used: 
				<literal>String</literal>, <literal>Char</literal>, <literal>Int32</literal>, 
				<literal>Byte</literal>, <literal>Int16</literal>, <literal>Boolean</literal>, 
				<literal>YesNo</literal>, <literal>TrueFalse</literal>.
			</para>
	        
			<programlisting>&lt;discriminator
	column="discriminator_column"<co id="discriminator1-co" linkends="discriminator1" />
	type="discriminator_type"<co id="discriminator2-co" linkends="discriminator2" />
	force="true|false"<co id="discriminator3-co" linkends="discriminator3" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="discriminator1-co" id="discriminator1">
					<para>
						<literal>column</literal> (optional - defaults to <literal>class</literal>) the
						name of the discriminator column.
					</para>
				</callout>
				<callout arearefs="discriminator2-co" id="discriminator2">
					<para>
						<literal>type</literal> (optional - defaults to <literal>String</literal>) a
						name that indicates the Hibernate type
					</para>
				</callout>          
				<callout arearefs="discriminator3-co" id="discriminator3">
					<para>
						<literal>force</literal> (optional - defaults to <literal>false</literal>) 
						"force" NHibernate to specify allowed discriminator values even when retrieving 
						all instances of the root class.
					</para>
				</callout>          
			</calloutlist>

			<para>
				Actual values of the discriminator column are specified by the
				<literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and
				<literal>&lt;subclass&gt;</literal> elements.
			</para>
	        
			<para>
				The <literal>force</literal> attribute is (only) useful if the table contains rows with
				"extra" discriminator values that are not mapped to a persistent class. This will not
				usually be the case.
			</para>
		</sect2>

		<sect2 id="mapping-declaration-version">
			<title>version (optional)</title>
	        
			<para>
				The <literal>&lt;version&gt;</literal> element is optional and indicates that
				the table contains versioned data. This is particularly useful if you plan to
				use <emphasis>long transactions</emphasis> (see below).
			</para>
		    
			<programlisting>&lt;version
	column="version_column"<co id="version1-co" linkends="version1" />
	name="propertyName"<co id="version2-co" linkends="version2" />
	type="typename"<co id="version3-co" linkends="version3" />
	access="field|property|nosetter|ClassName"<co id="version4-co" linkends="version4" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="version1-co" id="version1">
					<para>
						<literal>column</literal> (optional - defaults to the property name): The name
						of the column holding the version number.
					</para>
				</callout>          
				<callout arearefs="version2-co" id="version2">
					<para>
						<literal>name</literal>: The name of a property  of the persistent class.
					</para>
				</callout>
				<callout arearefs="version3-co" id="version3">
					<para>
						<literal>type</literal> (optional - defaults to <literal>Int32</literal>): 
						The type of the version number.
					</para>
				</callout>          
				<callout arearefs="version4-co" id="version4">
					<para>
						<literal>access</literal> (optional - defaults to <literal>property</literal>): The
						strategy NHibernate should use for accessing the property value.
					</para>
				</callout>
			</calloutlist>
	        
			<para>
				Version numbers may be of type <literal>Int64</literal>, <literal>Int32</literal>,
				<literal>Int16</literal>, <literal>Ticks</literal>, <literal>Timestamp</literal>, 
				or <literal>TimeSpan</literal>.
			</para>

		</sect2>
	        
		<sect2 id="mapping-declaration-timestamp">
			<title>timestamp (optional)</title>

			<para>
				The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains 
				timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
				a less safe implementation of optimistic locking. However, sometimes the application might
				use the timestamps in other ways.
			</para>
	        
			<programlisting>&lt;timestamp
	column="timestamp_column"<co id="timestamp1-co" linkends="timestamp1" />
	name="propertyName"<co id="timestamp2-co" linkends="timestamp2" />
	access="field|property|nosetter|ClassName"<co id="timestamp3-co" linkends="timestamp3" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="timestamp1-co" id="timestamp1">
					<para>
						<literal>column</literal> (optional - defaults to the property name): The name
						of a column holding the timestamp.
					</para>
				</callout>                   
				<callout arearefs="timestamp2-co" id="timestamp2">
					<para>
						<literal>name</literal>: The name of a property of .NET type <literal>DateTime</literal>.
					</para>
				</callout>
				<callout arearefs="timestamp3-co" id="timestamp3">
					<para>
						<literal>access</literal> (optional - defaults to <literal>property</literal>): The
						strategy NHibernate should use for accessing the property value.
					</para>
				</callout>
			</calloutlist>
	        
			<para>
				Note that <literal>&lt;timestamp&gt;</literal> is equivalent to 
				<literal>&lt;version type="timestamp"&gt;</literal>.
			</para>
		</sect2>

		<sect2 id="mapping-declaration-property">
			<title>property</title>

			<para>
				The <literal>&lt;property&gt;</literal> element declares a persistent, 
				property of the class.
			</para>
	        
			<programlisting>&lt;property
	name="propertyName"<co id="property1-co" linkends="property1" />
	column="column_name"<co id="property2-co" linkends="property2" />
	type="typename"<co id="property3-co" linkends="property3" />
	update="true|false"<co id="property4-co" linkends="property4" />
	insert="true|false"<co id="property5-co" linkends="property5" />
	formula="arbitrary SQL expression"<co id="property6-co" linkends="property6" />
	access="field|property|nosetter|ClassName"<co id="property7-co" linkends="property7" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="property1-co" id="property1">
					<para>
						<literal>name</literal>: the name of the property in the same case as the Propery in your API
					</para>
				</callout>                   
				<callout arearefs="property2-co" id="property2">
					<para>
						<literal>column</literal> (optional - defaults to the property name): the name
						of the mapped database table column.
					</para>
				</callout>
				<callout arearefs="property3-co" id="property3">
					<para>
						<literal>type</literal> (optional): a name that indicates the NHibernate type.
					</para>
				</callout>
				<callout arearefs="property4-co" id="property4">
					<para>
						<literal>update</literal> (optional - defaults to <literal>true</literal>) :
						specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> 
					</para>
				</callout>
				<callout arearefs="property5-co" id="property5">
					<para>
						<literal>insert</literal> (optional - defaults to <literal>true</literal>) :
						specifies that the mapped columns should be included in SQL 
						<literal>INSERT</literal> statements. Setting both <literal>insert</literal>
						and <literal>update</literal> to <literal>false</literal>
						allows a pure "derived" property whose value is initialized from some other
						property that maps to the same colum(s) or by a trigger or other application.
					</para>
				</callout>
				<callout arearefs="property6-co" id="property6">
					<para>
						<literal>formula</literal> (optional): an SQL expression that defines the value for a
						<emphasis>computed</emphasis> property. Computed properties do not have a column
						mapping of their own.
					</para>
				</callout>
				<callout arearefs="property7-co" id="property7">
					<para>
						<literal>access</literal> (optional - defaults to <literal>property</literal>): The
						strategy NHibernate should use for accessing the property value.
					</para>
				</callout>
			</calloutlist>

			<para>
				<emphasis>typename</emphasis> could be:
			</para>

			<orderedlist spacing="compact">
				<listitem>
					<para>
						The name of a NHibernate basic type (eg. <literal>Int32, String, Char,
						DateTime, Timstamp, Single, Byte[], Object, ...</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a .NET type with a default basic type (eg. <literal>System.Int16, System.Single,
						System.Char, System.String, System.DateTime, System.Byte[], ...</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a your of <literal>System.Enum </literal> (eg. <literal>Eg.Color</literal>).
					</para>
				</listitem>
				<listitem>
					<para>
						The name of a serializable .NET type.
					</para>
				</listitem>
				<listitem>
					<para>
						The type of a custom type (eg. <literal>Illflow.Type.MyCustomType, Illflow</literal>).
					</para>
				</listitem>
			</orderedlist>

			<para>
				If you do not specify a type, NHibernate will use reflection upon the named
				property to take a guess at the correct NHibernate type. NHibernate will try to
				interpret the name of the return class of the property getter using rules 2, 3,
				4 in that order. However, this is not always enough.
				In certain cases you will still need the <literal>type</literal>
				attribute. (For example, to distinguish between <literal>NHibernate.DateTime</literal> and
				<literal>NHibernate.Timestamp</literal>, or to specify a custom type.)
			</para>
			
			<para>
				The <literal>access</literal> attribute lets you control how NHibernate will access
				the value of the property at runtime.  The value of the <literal>access</literal> attribute should
				be text formatted as <literal>access-strategy.naming-strategy</literal>.  The 
				<literal>.naming-stragey</literal> is not always required.
				<table>
					<title>Access Strategy</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Access Strategy Name</entry>
								<entry>Description</entry>	
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>property</literal></entry>
								<entry>
									<para>
										The default implementation.  NHibernate uses the get/set of your Property.  No
										Naming Strategy should be used with this Access Strategy because the 
										<literal>name</literal> attribute is the name of the Property.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>field</literal></entry>
								<entry>
									<para>
										NHibernate will access the Field directly.  NHibernate uses the <literal>&lt;name&gt;</literal>
										as the name of the field.  This can be used when a Property's get and set have extra
										actions in them that you don't want to occur when NHibernate is populating or reading the object.  
										If you want the name of the Property and not the Field to be what the consumers of your API 
										use with HQL, then a Naming Strategy is needed.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>nosetter</literal></entry>
								<entry>
									<para>
										NHibernate will access the Field directly when setting the value and will use the
										Property when getting the value.  This can be used when a Property only exposes a get because
										the consumers of your API can't change the value directly.  A Naming Strategy is required
										because NHibernate uses the <literal>name</literal> attribute as the Property so it needs to 
										be told what the name of the Field is.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>ClassName</literal></entry>
								<entry>
									<para>
										If NHibernate's built in Access Strategies are not what is needed for your situation
										then you can build your own by implementing the interface 
										<literal>NHibernate.Property.IPropertyAccessor</literal>.  The value of the 
										<literal>access</literal> attribute should be an Assembly Qualified Name that can be 
										loaded with <literal>Activator.CreateInstance(string AssemblyQualifiedName)</literal>.
									</para>
								</entry>	
							</row>	
						</tbody>	
					</tgroup>		
				</table>
			</para>
			
			<para>
				<table>
					<title>Naming Strategy</title>
					<tgroup cols="2">
						<thead>
							<row>
								<entry>Naming Strategy Name</entry>
								<entry>Description</entry>	
							</row>
						</thead>
						<tbody>
							<row>
								<entry><literal>camelcase</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is converted to CamelCase to find the Field.
										<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>foo</literal>.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>camelcase-underscore</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is converted to CamelCase and prefixed with an
										underscore to find the Field.
										<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>_foo</literal>.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>lowercase-underscore</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is converted to all LowerCase and prefixed with an
										underscore to find the Field.
										<literal>&lt;property name="FooBar" ... &gt;</literal> uses the Field <literal>_foobar</literal>.
									</para>
								</entry>	
							</row>	
							<row>
								<entry><literal>pascalcase-m-underscore</literal></entry>
								<entry>
									<para>
										The <literal>name</literal> attribute is prefixed with the character
										<literal>m</literal> and an underscore to find the Field.
										<literal>&lt;property name="Foo" ... &gt;</literal> uses the Field <literal>m_Foo</literal>.
									</para>
								</entry>	
							</row>	
						</tbody>
					</tgroup>
				</table>
			</para>
		</sect2>
		<sect2 id="mapping-declaration-manytoone">
			<title>many-to-one</title>

			<para>An ordinary association to another persistent class is declared
			using a many-to-one element. The relational model is a many-to-one
			association. (Its really just an object reference.) </para>

            <programlisting>&lt;many-to-one
        name="propertyName"<co id="manytoone1-co" />
        column="column_name"<co id="manytoone2-co" />
        class="ClassName"<co id="manytoone3-co" />
        cascade="all|none|save-update|delete"<co id="manytoone4-co" />
        outer-join="true|false|auto"<co id="manytoone5-co" />
        update="true|false"<co id="manytoone6-co" />
        insert="true|false"<co id="manytoone7-co" />
        access="field|property|ClassName"<co id="manytoone8-co" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="manytoone1-co" id="manytoone1">
					<para>
						<literal>name</literal>: The name of the property.
					</para>   
				</callout>
				<callout arearefs="manytoone2-co" id="manytoone2">
					<para>
						<literal>column</literal> (optional): The name of the column.
					</para>  
				</callout>
				<callout arearefs="manytoone3-co" id="manytoone3">
					<para>
						<literal>class</literal> (optional - defaults to the property type
						determined by reflection): The name of the associated class.
					</para>
				</callout>
				<callout arearefs="manytoone4-co" id="manytoone4">
					<para>
						<literal>cascade</literal> (optional): Specifies which operations should
						be cascaded from the parent object to the associated object.
					</para>    
				</callout>
				<callout arearefs="manytoone5-co" id="manytoone5">
					<para>
						<literal>outer-join</literal> (optional - defaults to <literal>auto</literal>): 
						enables outer-join fetching for this association when 
						<literal>hibernate.use_outer_join</literal> is set.
					</para> 
				</callout>
				<callout arearefs="manytoone6-co" id="manytoone6">
					<para>
						<literal>update, insert</literal> (optional - defaults to <literal>true</literal>) 
						specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> 
						and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal>
						allows a pure "derived" association whose value is initialized from some other
						property that maps to the same colum(s) or by a trigger or other application.
					</para>   
				</callout>
				<callout arearefs="manytoone8-co" id="manytoone8">
					<para>
						<literal>access</literal> (optional - defaults to
						<literal>property</literal>): The strategy NHibernate should use for
						accessing the property value.
					</para>
				</callout>
		</calloutlist>
		<para>
			The <literal>cascade</literal> attribute permits the following values: 
			<literal>all</literal>, <literal>save-update</literal>, <literal>delete</literal>,
			<literal>none</literal>. Setting a value other than <literal>none</literal>
			will propagate certain operations to the associated (child) object.
			See "Lifecycle Objects" below.
		</para>
		
		<para>
			The <literal>outer-join</literal> attribute accepts three different values:
		</para>
		
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					<literal>auto</literal> (default) Fetch the association using an
					outerjoin if the associated class has no proxy
				</para>
			</listitem>
			<listitem>
				<para>
					<literal>true</literal> Always fetch the association using an 
					outerjoin
				</para>
			</listitem>
			<listitem>
				<para>
					<literal>false</literal> Never fetch the association using an
					outerjoin
				</para>
			</listitem>
		</itemizedlist>
	</sect2>
	<sect2 id="mapping-declaration-onetoone">
		<title>one-to-one</title>
		
		<para>
			A one-to-one association to another persistent class is declared using a 
			<literal>one-to-one</literal> element.
		</para>
		<programlisting>&lt;one-to-one
	name="propertyName"<co id="onetoone1-co" />
	class="ClassName"<co id="onetoone2-co" />
	cascade="all|none|save-update|delete"<co id="onetoone3-co" />
	constrained="true|false"<co id="onetoone4-co" />
	outer-join="true|false|auto"<co id="onetoone5-co" />
	access="field|property|ClassName"<co id="onetoone6-co" />
/&gt;</programlisting>
		<calloutlist>
			<callout arearefs="onetoone1-co" id="onetoone1">
				<para>
					<literal>name</literal>: The name of the property.
				</para>     
			</callout>
			<callout arearefs="onetoone2-co" id="onetoone2">
				<para>
					<literal>class</literal> (optional - defaults to the property type
					determined by reflection): The name of the associated class.
				</para>  
			</callout>
			<callout arearefs="onetoone3-co" id="onetoone3">
				<para>
					<literal>cascade</literal> (optional) specifies which operations should
					be cascaded from the parent object to the associated object.
				</para>
			</callout>
			<callout arearefs="onetoone4-co" id="onetoone4">
				<para>
					<literal>contstrainted</literal> (optional) specifies that a foreign key constraint
					on the primary key of the mapped table references the table of the associated 
					class.  This options affects the order in which <literal>Save()</literal> and 
					<literal>Delete()</literal> are cascaded (and is also used by the schema export tool).
				</para>
			</callout>
			<callout arearefs="onetoone5-co" id="onetoone5">
				<para>
					<literal>outer-join</literal> (optional - defaults to <literal>auto</literal>): 
					Enable outer-join fetching for this association when <literal>hibernate.use_outer_join</literal>
					is set.
				</para>
			</callout>
			<callout arearefs="onetoone6-co" id="onetoone6">
				<para>
					<literal>access</literal> (optional - defaults to <literal>property</literal>): The
					strategy NHibernate should use for accessing the property value.
				</para>
			</callout>
		</calloutlist>
		<!-- TODO: add details about the new property-ref attribute that Paul added -->
	</sect2>
	<sect2 id="mapping-declaration-component">
		<title>component, dynamic-component</title>
		
		<para>
			The <literal>&lt;component&gt;</literal> element maps properties of a
			child object to columns of the table of a parent class. Components may, in
			turn, declare their own properties, components or collections. See
			"Components" below.
		</para>
		<programlisting>&lt;component
	name="propertyName"<co id="component1-co" />
	class="ClassName"<co id="component2-co" />
	insert="true|false"<co id="component3-co" />
	update="true|false"<co id="component4-co" />
	access="field|property|ClassName"<co id="component5-co" />
/&gt;</programlisting>
		<calloutlist>
			<callout arearefs="component1-co" id="component1">
				<para>
					<literal>name</literal>: The name of the property.
				</para>     
			</callout>
			<callout arearefs="component2-co" id="component2">
				<para>
					<literal>class</literal> (optional - defaults to the property type
					determined by reflection): The name of the component (child) class.
				</para>  
			</callout>
			<callout arearefs="component3-co" id="component3">
				<para>
					<literal>insert</literal>: Do the mapped columns appear in SQL 
					<literal>INSERT</literal>s?
				</para>
			</callout>
			<callout arearefs="component4-co" id="component4">
				<para>
					<literal>update</literal>: Do the mapped columns appear in SQL 
					<literal>UPDATE</literal>s?
				</para>
			</callout>
			<callout arearefs="component5-co" id="component5">
				<para>
					<literal>access</literal> (optional - defaults to <literal>property</literal>): The
					strategy Hibernate should use for accessing the property value.
				</para>
			</callout>
		</calloutlist>
	</sect2>
	<sect2 id="mapping-declaration-subclass">
		<title>subclass</title>
		
		<para>
			Finally, polymorphic persistence requires the declaration of each subclass of
			the root persistent class. For the (recommended) table-per-class-hierarchy
			mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used.
		</para>
		<programlisting>&lt;subclass
	name="ClassName"<co id="subclass1-co" />
	discriminator-value="discriminator_value"<co id="subclass2-co" />
	proxy="ProxyInterface"<co id="subclass3-co" />
	dynamic-update="true|false"
	dynamic-insert="true|false"
	extends="BaseMappedClassName"&gt; <co id="subclass4-co" />
	
	&lt;property ... / &gt;
	...
&lt;subclass/&gt;</programlisting>
		<calloutlist>
			<callout arearefs="subclass1-co" id="subclass1">
				<para>
					<literal>name</literal>: The fully qualified .NET Type name of the persistent class. 
				</para>
			</callout>	
			<callout arearefs="subclass2-co" id="subclass2">
				<para>
					<literal>discriminator-value</literal> (optional - defaults to the class name): A 
					value that distinguishes individual subclasses.
				</para>
			</callout>	
			<callout arearefs="subclass3-co" id="subclass3">
				<para>
					<literal>proxy</literal> (optional): Specifies a class or interface to use 
					for lazy initializing proxies.
				</para>
			</callout>	
			<callout arearefs="subclass4-co" id="subclass4">
				<para>
					<literal>extends</literal> (optional): Specifies the mapped class that this
					subclass is extending.  This is only needed if <link linkend="mapping-modularfiles">
					Modular Mapping Files</link> are used.
				</para>
			</callout>		
		</calloutlist>
	</sect2>
	<sect2 id="mapping-declaration-joinedsubclass">
		<title>joined-subclass</title>
		
		<para>
			Alternatively, a subclass that is persisted to its own table (table-per-subclass 
			mapping strategy) is declared using a <literal>&lt;joined-subclass&gt;</literal>
			element.
		</para>
		
		<programlisting>&lt;joined-subclass
	name="ClassName"<co id="joinedsubclass1-co" />
	table="tableName" <co id="joinedsubclass2-co" />
	proxy="ProxyInterface"<co id="joinedsubclass3-co" />
	dynamic-update="true|false"
	dynamic-insert="true|false"
	extends="BaseMappedClassName"&gt; <co id="joinedsubclass4-co" />
	
	&lt;key ... &gt;
	
	&lt;property ... / &gt;
	...
&lt;joined-subclass/&gt;</programlisting>
		<calloutlist>
			<callout arearefs="joinedsubclass1-co" id="joinedsubclass1">
				<para>
					<literal>name</literal>: The fully qualified .NET Type name of the persistent class. 
				</para>
			</callout>
			<callout arearefs="joinedsubclass2-co" id="joinedsubclass2">
				<para>
					<literal>table</literal>: The name of the table that holds the data specific to this class.
				</para>
			</callout>	
			<callout arearefs="joinedsubclass3-co" id="joinedsubclass3">
				<para>
					<literal>proxy</literal> (optional): Specifies a class or interface to use 
					for lazy initializing proxies.
				</para>
			</callout>	
			<callout arearefs="joinedsubclass4-co" id="joinedsubclass4">
				<para>
					<literal>extends</literal> (optional): Specifies the mapped class that this
					joined-subclass is extending.  This is only needed if 
					<link linkend="mapping-modularfiles">Modular Mapping Files</link> are used.
				</para>
			</callout>	
		</calloutlist>
		<para>
			No discriminator column is required for this mapping strategy.  Each sublcass must, 
			however, declare a table column holding the object identifier using the 
			<literal>&lt;key&gt;</literal> element.
		</para>
		</sect2>
		<sect2 id="mapping-declaration-collections">
			<title>map, set, list, bag</title>
		
			<para>
				Collections are discussed later.
			</para>
		</sect2>
		
		<sect2 id="mapping-declaration-import">
			<title>import</title>
			<para>
				If your application has two persistent class with the same name, and you don't want to 
				specify the fully qualified name in NHibernate queries, then classes may be "imported"
				explicity, rather than relying on <literal>auto-import="true"</literal>.  Classes and interfaces
				that are not explicity mapped can be imported also.  This is useful when you want to query for
				classes that implement a certain interface or want to use an unmapped class to put the results
				of the hql in.
			</para>
			<programlisting>&lt;import class="System.Object, System" /&gt;</programlisting>
			<programlisting>&lt;import 
	class="className" <co id="import1-co" />
	rename="newName"  <co id="import2-co" />
/&gt;</programlisting>
			<calloutlist>
				<callout arearefs="import1-co" id="import1">
					<para>
						<literal>class</literal>:  The fully qualified .NET Type name of the persistent class (or interface).
					</para>
				</callout>
				<callout arearefs="import2-co" id="import2">
					<para>
						<literal>rename</literal> (optional - defaults to the unqualified class name): A
						name that may be used in the query language.
					</para>
				</callout>
			</calloutlist>
		</sect2>
	</sect1>
	<sect1 id="mapping-types">
		<title>NHibernate Types</title>
		<sect2 id="mapping-types-entitiesvalues">
			<title>Entities and values</title>

			<para>
				To understand the behaviour of various .NET language-level objects with respect
				to the persistence service, we need to classify them into two groups:
			</para>

			<para>
				An <emphasis>entity</emphasis> exists independently of any other objects holding
				references to the entity. Contrast this with the usual .NET model where an
				unreferenced object is garbage collected. Entities must be explicitly saved and
				deleted (except that saves and deletions may be <emphasis>cascaded</emphasis>
				from a parent entity to its children).  Entities support
				circular and shared references. They may also be versioned.
			</para>

			<para>
				An entity's persistent state consists of references to other entities and
				instances of <emphasis>value</emphasis> types. Values are structs,
				collections, components and certain immutable objects. Unlike entities, values
				(in particular collections and components) <emphasis>are</emphasis>
				persisted and deleted by reachability. Since value objects (and structs) are
				persisted and deleted along with their containing entity they may not be
				independently versioned. Values have no independent identity, so they cannot be
				shared by two entities or collections.
			</para>

			<para>
				All NHibernate types except collections support null semantics if the .NET type also
				supports it.
			</para>

			<para>
				Up until now, we've been using the term "persistent class" to refer to
				entities. We will continue to do that. Strictly speaking, however, not all
				user-defined classes with persistent state are entities. A
				<emphasis>component</emphasis> is a user defined class with value semantics.
			</para>
		</sect2>
		
		<sect2 id="mapping-types-basictypes">
			<title>Basic value types</title>

			<para>
				The <emphasis>basic types</emphasis> may be roughly categorized into three groups - <literal>System.ValueType</literal> 
				types, <literal>System.Object</literal> types, and <literal>System.Object</literal> types for large objects.  Just like
				the .NET Types, columns for System.ValueType types <emphasis>can not</emphasis> store <literal>null</literal> values 
				and System.Object types	<emphasis>can</emphasis> store <literal>null</literal> values.
			</para>
			<table>
				<title>System.ValueType Mapping Types</title>
				<tgroup cols="4">
					<thead>
						<row>
							<entry>NHibernate Type</entry>
							<entry>.NET Type</entry>
							<entry>Database Type</entry>
							<entry>Remarks</entry>	
						</row>
					</thead>	
					<tbody>
						<row>
							<entry><literal>Boolean</literal></entry>
							<entry><literal>System.Boolean</literal></entry>
							<entry><literal>DbType.Boolean</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Byte</literal></entry>
							<entry><literal>System.Byte</literal></entry>
							<entry><literal>DbType.Byte</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Char</literal></entry>
							<entry><literal>System.Char</literal></entry>
							<entry><literal>DbType.StringFixedLength - 1 char</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>DateTime</literal></entry>
							<entry><literal>System.DateTime</literal></entry>
							<entry><literal>DbType.DateTime</literal> - ignores the milliseconds</entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Decimal</literal></entry>
							<entry><literal>System.Decimal</literal></entry>
							<entry><literal>DbType.Decimal</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Double</literal></entry>
							<entry><literal>System.Double</literal></entry>
							<entry><literal>DbType.Double</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Guid</literal></entry>
							<entry><literal>System.Guid</literal></entry>
							<entry><literal>DbType.Guid</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Int16</literal></entry>
							<entry><literal>System.Int16</literal></entry>
							<entry><literal>DbType.Int16</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Int32</literal></entry>
							<entry><literal>System.Int32</literal></entry>
							<entry><literal>DbType.Int32</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Int64</literal></entry>
							<entry><literal>System.Int64</literal></entry>
							<entry><literal>DbType.Int64</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>PersistentEnum</literal></entry>
							<entry>A <literal>System.Enum</literal></entry>
							<entry>The <literal>DbType</literal> for the underlying value.</entry>
							<entry>Do not specify <literal>type="PersistentEnum"</literal> in the mapping.  Instead 
							specify the Assembly Qualified Name of the Enum or let NHibernate use Reflection to "guess" the Type.  
							The UnderlyingType of the Enum is used to determine the correct <literal>DbType</literal>.</entry>
						</row>
						<row>
							<entry><literal>Single</literal></entry>
							<entry><literal>System.Single</literal></entry>
							<entry><literal>DbType.Single</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Ticks</literal></entry>
							<entry><literal>System.DateTime</literal></entry>
							<entry><literal>DbType.Int64</literal></entry>
							<entry><literal>type="Ticks"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>TimeSpan</literal></entry>
							<entry><literal>System.TimeSpan</literal></entry>
							<entry><literal>DbType.Int64</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Timestamp</literal></entry>
							<entry><literal>System.DateTime</literal></entry>
							<entry><literal>DbType.DateTime</literal> - as specific as database supports.</entry>
							<entry><literal>type="Timestamp"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>TrueFalse</literal></entry>
							<entry><literal>System.Boolean</literal></entry>
							<entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'T' or 'F'</entry>
							<entry><literal>type="TrueFalse"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>YesNo</literal></entry>
							<entry><literal>System.Boolean</literal></entry>
							<entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'Y' or 'N'</entry>
							<entry><literal>type="YesNo"</literal> must be specified.</entry>
						</row>
					</tbody>
				</tgroup>	
			</table>
			
			<table>
				<title>System.Object Mapping Types</title>
				<tgroup cols="4">
					<thead>
						<row>
							<entry>NHibernate Type</entry>
							<entry>.NET Type</entry>
							<entry>Database Type</entry>
							<entry>Remarks</entry>	
						</row>
					</thead>	
					<tbody>
						<row>
							<entry><literal>AnsiString</literal></entry>
							<entry><literal>System.String</literal></entry>
							<entry><literal>DbType.AnsiString</literal></entry>
							<entry><literal>type="AnsiString"</literal> must be specified.</entry>
						</row>
						<row>
							<entry><literal>CultureInfo</literal></entry>
							<entry><literal>System.Globalization.CultureInfo</literal></entry>
							<entry><literal>DbType.String</literal> - 5 chars for culture</entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Binary</literal></entry>
							<entry><literal>System.Byte[]</literal></entry>
							<entry><literal>DbType.Binary</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>Type</literal></entry>
							<entry><literal>System.Type</literal></entry>
							<entry><literal>DbType.String</literal> holding Assembly Qualified Name.</entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
						<row>
							<entry><literal>String</literal></entry>
							<entry><literal>System.String</literal></entry>
							<entry><literal>DbType.String</literal></entry>
							<entry>Default when no <literal>type</literal> attribute specified.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>	
			
			<table>
				<title>Large Object Mapping Types</title>
				<tgroup cols="4">
					<thead>
						<row>
							<entry>NHibernate Type</entry>
							<entry>.NET Type</entry>
							<entry>Database Type</entry>	
							<entry>Remarks</entry>
						</row>
					</thead>	
					<tbody>
						<row>
							<entry><literal>StringClob</literal></entry>
							<entry><literal>System.String</literal></entry>
							<entry><literal>DbType.String</literal></entry>
							<entry><literal>type="StringClob"</literal> must be specified.  Entire field is read into memory.</entry>
						</row>
						<row>
							<entry><literal>BinaryBlob</literal></entry>
							<entry><literal>System.Byte[]</literal></entry>
							<entry><literal>DbType.Binary</literal></entry>
							<entry><literal>type="BinaryBlob"</literal> must be specified.  Entire field is read into memory.</entry>
						</row>
						<row>
							<entry><literal>Serializable</literal></entry>
							<entry>Any <literal>System.Object</literal> that is marked with SerializableAttribute.</entry>
							<entry><literal>DbType.Binary</literal></entry>
							<entry><literal>type="Serializable"</literal> should be specified.  This is the fallback type
							if no NHibernate Type can be found for the Property.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>	
			
			<para>
				For those of you coming over from Hibernate or using some of the tools to generate <literal>hbm.xml</literal> files
				that are intended for Hibernate, there is a Hibernate compatiblity layer for type names.  A <literal>type="integer"</literal>
				will map to an <literal>Int32</literal> NHibernateType, <literal>type="short"</literal> to an <literal>Int16</literal>
				NHibernateType.  To see all of the conversions you can view the source of static constructor of the class 
				<literal>NHibernate.Type.TypeFactory</literal>. 
			</para>
		</sect2>
		<sect2 id="mapping-types-custom">
			<title>Custom value types</title>
	
			<para>
				It is relatively easy for developers to create their own value types. For example,
				you might want to persist properties of type <literal>Int64</literal>
				to <literal>VARCHAR</literal> columns. NHibernate does not provide a built-in type 
				for this. But custom types are not limited to mapping a property (or collection element) 
				to a single table column. So, for example, you might have a property 
				<literal>Name {get; set;}</literal> of type <literal>String</literal> that is persisted to the columns 
				<literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>. 
			</para>
	
			<para>
				To implement a custom type, implement either <literal>NHibernate.IUserType</literal> 
				or <literal>NHibernate.ICompositeUserType</literal> and declare properties using the 
				fully qualified name of the type. Check out 
				<literal>NHibernate.DomainModel.DoubleStringType</literal> to see the kind of things that 
				are possible.
			</para>

			<programlisting><![CDATA[<property name="TwoStrings" type="NHibernate.DomainModel.DoubleStringType, NHibernate.DomainModel">
	<column name="first_string"/>
	<column name="second_string"/>
</property>]]></programlisting>

			<para>
				Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple
				columns.
			</para>
			<para>
				Even though NHibernate's rich range of built-in types and support for components means you
				will very rarely <emphasis>need</emphasis> to use a custom type, it is nevertheless
				considered good form to use custom types for (non-entity) classes that occur frequently
				in your application. For example, a <literal>MonetoryAmount</literal> class is a good
				candidate for a <literal>ICompositeUserType</literal>, even though it could easily be mapped 
				as a component. One motivation for this is abstraction. With a custom type, your mapping 
				documents would be future-proofed against possible changes in your way of representing 
				monetory values.
			</para>
		</sect2>
		<sect2 id="mapping-types-anymapping">
			<title>Any type mappings</title>
			<para>TODO</para>
		</sect2>
	
	</sect1>	

	
	<sect1 id="mapping-quotedidentifiers">
		<title>SQL quoted identifiers</title>
		<para>
			You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
			column name in backticks in the mapping document.  NHibernate will use the correct quotation
			style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL
			Server and backticks for MySQL).
		</para>

		<programlisting><![CDATA[
<class name="LineItem" table="`Line Item`">
	<id name="id" column="`Item Id`">
		<generator class="assigned"/>
	</id>
	<property name="itemNumber" column="`Item #`"/>
	...
</class>]]></programlisting>

	</sect1>
	<sect1 id="mapping-modularfiles">
		<title>Modular mapping files</title>
		<para>
			It is possible to define <literal>subclass</literal> and <literal>joined-subclass</literal>
			mappings in seperate mapping documents, directly beneath <literal>hibernate-mapping</literal>.
			This allows you to extend a class hierachy just by adding a new mapping file. You must
			specify an <literal>extends</literal> attribute in the subclass mapping, naming a previously
			mapped superclass.  If you are configuring NHibernate by using Embedded Resources then the
			hbm.xml files are configured in the correct order.  If you are manually adding them or specifying
			them in the cfg.xml file then the ordering of the mapping documents is important!
		</para>

		<programlisting><![CDATA[
<hibernate-mapping>
	<subclass name="Eg.Subclass.DomesticCat, Eg" extends="Eg.Cat, Eg" discriminator-value="D">
		<property name="Name" type="String"/>
	</subclass>
</hibernate-mapping>]]></programlisting>

	</sect1>

</chapter>