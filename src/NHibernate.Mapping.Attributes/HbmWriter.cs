// 
// NHibernate.Mapping.Attributes
// This product is under the terms of the GNU Lesser General Public License.
//
//
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
//
//
// This source code was auto-generated by Refly, Version=2.21.1.0 (modified).
//
namespace NHibernate.Mapping.Attributes
{
	
	
	/// <summary> Write a XmlSchemaElement from attributes in a System.Type. </summary>
	public class HbmWriter
	{
		
		private HbmWriterHelper _defaultHelper = new HbmWriterHelperEx();
		
		private System.Collections.Hashtable _patterns;
		
		/// <summary> Gets or sets the HbmWriterHelper used by HbmWriter </summary>
		public virtual HbmWriterHelper DefaultHelper
		{
			get
			{
				return this._defaultHelper;
			}
			set
			{
				this._defaultHelper = value;
			}
		}
		
		/// <summary> Gets or sets the Patterns to convert properties types (the key is the pattern string and the value is the replacement string) </summary>
		public virtual System.Collections.Hashtable Patterns
		{
			get
			{
				if(_patterns==null)
				{
					_patterns = new System.Collections.Hashtable();
					_patterns.Add(@"Nullables.Nullable(\w+), Nullables", "Nullables.NHibernate.Nullable$1Type, Nullables.NHibernate");
					_patterns.Add(@"System.Data.SqlTypes.Sql(\w+), System.Data", "NHibernate.UserTypes.SqlTypes.Sql$1Type, NHibernate.UserTypes.SqlTypes");
				}
				return _patterns;;
			}
			set
			{
				this._patterns = value;
			}
		}
		
		/// <summary> Searches the members of the class for any member with the attribute defined. </summary>
		public virtual System.Collections.ArrayList FindAttributedMembers(BaseAttribute rootAttrib, System.Type attributeType, System.Type classType)
		{
			// Return all members from the classType (and its base types) decorated with this attributeType
			System.Collections.ArrayList list = new System.Collections.ArrayList();
			System.Reflection.BindingFlags bindings = System.Reflection.BindingFlags.Instance
				| System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.DeclaredOnly;

			System.Type type = classType;
			while( type != null )
			{
				foreach( System.Reflection.MemberInfo member in type.GetMembers(bindings) )
				{
					foreach(BaseAttribute memberAttrib in GetSortedAttributes(member))
					{
						if( IsNextElement(memberAttrib, rootAttrib, attributeType) )
							break; // next attributes are for <sub-elements>
						else if( memberAttrib.GetType() == attributeType || memberAttrib.GetType().IsSubclassOf(attributeType) )
						{
							list.Add( member );
							break;
						}
					}
				}
				type = type.BaseType;
				if( type!=null && ( type.IsDefined(typeof(ComponentAttribute), false) || type.IsDefined(typeof(ClassAttribute), false)
					|| type.IsDefined(typeof(SubclassAttribute), false) || type.IsDefined(typeof(JoinedSubclassAttribute), false) ) )
					break; // don't use members of a mapped base class
			}

			return list;
		}
		
		/// <summary> Return all (BaseAttribute derived) attributes in the MethodDeclaration sorted using their position. </summary>
		public virtual System.Collections.ArrayList GetSortedAttributes(System.Reflection.MemberInfo member)
		{
			System.Collections.ArrayList list = new System.Collections.ArrayList();
			foreach(object attrib in member.GetCustomAttributes(false))
				if(attrib is BaseAttribute)
					list.Add(attrib);
			list.Sort();
			return list;
		}
		
		/// <summary> Tells if 'element1' come after 'element2' in rootType's 'sub-elements' order. </summary>
		public virtual bool IsNextElement(BaseAttribute element1, BaseAttribute baseAttrib, System.Type typeOfElement2)
		{
			if( element1 == null )
				return false;
			
			if( baseAttrib is HibernateMappingAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is ImportAttribute || element1 is ClassAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ImportAttribute) )
				{
					if( element1 is ClassAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ClassAttribute) )
				{
					if( element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SubclassAttribute) )
				{
					if( element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JoinedSubclassAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ImportAttribute )
			{
			}
			
			if( baseAttrib is ClassAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is IdAttribute || element1 is CompositeIdAttribute || element1 is DiscriminatorAttribute || element1 is VersionAttribute || element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is IdAttribute || element1 is CompositeIdAttribute || element1 is DiscriminatorAttribute || element1 is VersionAttribute || element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is IdAttribute || element1 is CompositeIdAttribute || element1 is DiscriminatorAttribute || element1 is VersionAttribute || element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IdAttribute) )
				{
					if( element1 is CompositeIdAttribute || element1 is DiscriminatorAttribute || element1 is VersionAttribute || element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeIdAttribute) )
				{
					if( element1 is DiscriminatorAttribute || element1 is VersionAttribute || element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(DiscriminatorAttribute) )
				{
					if( element1 is VersionAttribute || element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(VersionAttribute) )
				{
					if( element1 is TimestampAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(TimestampAttribute) )
				{
					if( element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToOneAttribute) )
				{
					if( element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ComponentAttribute) )
				{
					if( element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(DynamicComponentAttribute) )
				{
					if( element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(AnyAttribute) )
				{
					if( element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(MapAttribute) )
				{
					if( element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SetAttribute) )
				{
					if( element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ListAttribute) )
				{
					if( element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(BagAttribute) )
				{
					if( element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IdBagAttribute) )
				{
					if( element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ArrayAttribute) )
				{
					if( element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PrimitiveArrayAttribute) )
				{
					if( element1 is SubclassAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SubclassAttribute) )
				{
					if( element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JoinedSubclassAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is IdAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is ColumnAttribute || element1 is GeneratorAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( element1 is GeneratorAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(GeneratorAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is CompositeIdAttribute )
			{
				if( typeOfElement2 == typeof(KeyPropertyAttribute) )
				{
					if( element1 is KeyManyToOneAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyManyToOneAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is DiscriminatorAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is VersionAttribute )
			{
			}
			
			if( baseAttrib is TimestampAttribute )
			{
			}
			
			if( baseAttrib is SubclassAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToOneAttribute) )
				{
					if( element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ComponentAttribute) )
				{
					if( element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(DynamicComponentAttribute) )
				{
					if( element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(AnyAttribute) )
				{
					if( element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(MapAttribute) )
				{
					if( element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SetAttribute) )
				{
					if( element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ListAttribute) )
				{
					if( element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(BagAttribute) )
				{
					if( element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IdBagAttribute) )
				{
					if( element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ArrayAttribute) )
				{
					if( element1 is PrimitiveArrayAttribute || element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PrimitiveArrayAttribute) )
				{
					if( element1 is SubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SubclassAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is JoinedSubclassAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is KeyAttribute || element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToOneAttribute) )
				{
					if( element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ComponentAttribute) )
				{
					if( element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(DynamicComponentAttribute) )
				{
					if( element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(AnyAttribute) )
				{
					if( element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(MapAttribute) )
				{
					if( element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SetAttribute) )
				{
					if( element1 is ListAttribute || element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ListAttribute) )
				{
					if( element1 is BagAttribute || element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(BagAttribute) )
				{
					if( element1 is IdBagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IdBagAttribute) )
				{
					if( element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ArrayAttribute) )
				{
					if( element1 is PrimitiveArrayAttribute || element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PrimitiveArrayAttribute) )
				{
					if( element1 is JoinedSubclassAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JoinedSubclassAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is PropertyAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is ColumnAttribute || element1 is TypeAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( element1 is TypeAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(TypeAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is MetaValueAttribute )
			{
			}
			
			if( baseAttrib is AnyAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is MetaValueAttribute || element1 is ColumnAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(MetaValueAttribute) )
				{
					if( element1 is ColumnAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ArrayAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IndexAttribute) )
				{
					if( element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToManyAttribute) )
				{
					if( element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToManyAttribute) )
				{
					if( element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeElementAttribute) )
				{
					if( element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToAnyAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is CacheAttribute )
			{
			}
			
			if( baseAttrib is CollectionIdAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is ColumnAttribute || element1 is GeneratorAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( element1 is GeneratorAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(GeneratorAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ColumnAttribute )
			{
			}
			
			if( baseAttrib is ComponentAttribute )
			{
				if( typeOfElement2 == typeof(ParentAttribute) )
				{
					if( element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToOneAttribute) )
				{
					if( element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ComponentAttribute) )
				{
					if( element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(DynamicComponentAttribute) )
				{
					if( element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(AnyAttribute) )
				{
					if( element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(MapAttribute) )
				{
					if( element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SetAttribute) )
				{
					if( element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ListAttribute) )
				{
					if( element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(BagAttribute) )
				{
					if( element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ArrayAttribute) )
				{
					if( element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PrimitiveArrayAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is DynamicComponentAttribute )
			{
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is OneToOneAttribute || element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToOneAttribute) )
				{
					if( element1 is ComponentAttribute || element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ComponentAttribute) )
				{
					if( element1 is DynamicComponentAttribute || element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(DynamicComponentAttribute) )
				{
					if( element1 is AnyAttribute || element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(AnyAttribute) )
				{
					if( element1 is MapAttribute || element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(MapAttribute) )
				{
					if( element1 is SetAttribute || element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(SetAttribute) )
				{
					if( element1 is ListAttribute || element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ListAttribute) )
				{
					if( element1 is BagAttribute || element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(BagAttribute) )
				{
					if( element1 is ArrayAttribute || element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ArrayAttribute) )
				{
					if( element1 is PrimitiveArrayAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PrimitiveArrayAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is CompositeElementAttribute )
			{
				if( typeOfElement2 == typeof(ParentAttribute) )
				{
					if( element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is NestedCompositeElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is NestedCompositeElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is NestedCompositeElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(NestedCompositeElementAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is CompositeIndexAttribute )
			{
				if( typeOfElement2 == typeof(KeyPropertyAttribute) )
				{
					if( element1 is KeyManyToOneAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyManyToOneAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ElementAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is GeneratorAttribute )
			{
				if( typeOfElement2 == typeof(ParamAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is IdBagAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is CollectionIdAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is CollectionIdAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is CollectionIdAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CollectionIdAttribute) )
				{
					if( element1 is KeyAttribute || element1 is ElementAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is ElementAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToManyAttribute) )
				{
					if( element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeElementAttribute) )
				{
					if( element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToAnyAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is IndexAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is IndexManyToAnyAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is IndexManyToManyAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is JcsCacheAttribute )
			{
			}
			
			if( baseAttrib is KeyAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is KeyManyToOneAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is KeyPropertyAttribute )
			{
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ManyToAnyAttribute )
			{
				if( typeOfElement2 == typeof(MetaValueAttribute) )
				{
					if( element1 is ColumnAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ManyToManyAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is ColumnAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ManyToOneAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is ColumnAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ColumnAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is MetaAttribute )
			{
			}
			
			if( baseAttrib is NestedCompositeElementAttribute )
			{
				if( typeOfElement2 == typeof(ParentAttribute) )
				{
					if( element1 is PropertyAttribute || element1 is ManyToOneAttribute || element1 is NestedCompositeElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(PropertyAttribute) )
				{
					if( element1 is ManyToOneAttribute || element1 is NestedCompositeElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToOneAttribute) )
				{
					if( element1 is NestedCompositeElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(NestedCompositeElementAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is OneToManyAttribute )
			{
			}
			
			if( baseAttrib is OneToOneAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ParamAttribute )
			{
			}
			
			if( baseAttrib is ParentAttribute )
			{
			}
			
			if( baseAttrib is PrimitiveArrayAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is IndexAttribute || element1 is ElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IndexAttribute) )
				{
					if( element1 is ElementAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is ListAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is KeyAttribute || element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is IndexAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IndexAttribute) )
				{
					if( element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToManyAttribute) )
				{
					if( element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToManyAttribute) )
				{
					if( element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeElementAttribute) )
				{
					if( element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToAnyAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is BagAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is KeyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToManyAttribute) )
				{
					if( element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToManyAttribute) )
				{
					if( element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeElementAttribute) )
				{
					if( element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToAnyAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is SetAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is KeyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is KeyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToManyAttribute) )
				{
					if( element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToManyAttribute) )
				{
					if( element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeElementAttribute) )
				{
					if( element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToAnyAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is MapAttribute )
			{
				if( typeOfElement2 == typeof(MetaAttribute) )
				{
					if( element1 is JcsCacheAttribute || element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is CompositeIndexAttribute || element1 is IndexManyToManyAttribute || element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(JcsCacheAttribute) )
				{
					if( element1 is CacheAttribute || element1 is KeyAttribute || element1 is IndexAttribute || element1 is CompositeIndexAttribute || element1 is IndexManyToManyAttribute || element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CacheAttribute) )
				{
					if( element1 is KeyAttribute || element1 is IndexAttribute || element1 is CompositeIndexAttribute || element1 is IndexManyToManyAttribute || element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(KeyAttribute) )
				{
					if( element1 is IndexAttribute || element1 is CompositeIndexAttribute || element1 is IndexManyToManyAttribute || element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IndexAttribute) )
				{
					if( element1 is CompositeIndexAttribute || element1 is IndexManyToManyAttribute || element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeIndexAttribute) )
				{
					if( element1 is IndexManyToManyAttribute || element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IndexManyToManyAttribute) )
				{
					if( element1 is IndexManyToAnyAttribute || element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(IndexManyToAnyAttribute) )
				{
					if( element1 is ElementAttribute || element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ElementAttribute) )
				{
					if( element1 is OneToManyAttribute || element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(OneToManyAttribute) )
				{
					if( element1 is ManyToManyAttribute || element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToManyAttribute) )
				{
					if( element1 is CompositeElementAttribute || element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(CompositeElementAttribute) )
				{
					if( element1 is ManyToAnyAttribute || typeOfElement2 == null )
						return true;
				}
				if( typeOfElement2 == typeof(ManyToAnyAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			
			if( baseAttrib is TypeAttribute )
			{
				if( typeOfElement2 == typeof(ParamAttribute) )
				{
					if( typeOfElement2 == null )
						return true;
				}
			}
			return false;
		}
		
		/// <summary> Gets the xml enum value from the associated attributed enum. </summary>
		public virtual string GetXmlEnumValue(System.Type enumType, object enumValue)
		{
			// Enumeration's members have a XmlEnumAttribute; its Name is the value to return
			System.Reflection.FieldInfo[] fields = enumType.GetFields();
			foreach( System.Reflection.FieldInfo field in fields )
			{
				if( field.Name == System.Enum.GetName(enumType, enumValue) )
				{
					System.Xml.Serialization.XmlEnumAttribute attribute =
						System.Attribute.GetCustomAttribute( field, typeof(System.Xml.Serialization.XmlEnumAttribute), false ) as System.Xml.Serialization.XmlEnumAttribute;
					if( attribute != null )
						return attribute.Name;
					else
						throw new MappingException( string.Format( "{0} is missing XmlEnumAttribute on {1} value. Please, contact the NHibernate team to fix this issue.", enumType, enumValue ) );
				}
			}
			throw new MappingException( string.Format( "{0} doesn't contain the field {1}. Please, contact the NHibernate team to fix this issue.", enumType, enumValue ) );
		}
		
		/// <summary> Write user-defined content; should be of the specified contentAttributeType. </summary>
		public virtual void WriteUserDefinedContent(System.Xml.XmlWriter writer, System.Type classType, System.Type contentAttributeType, BaseAttribute parentAttribute)
		{
		}
		
		/// <summary> Write user-defined content; should be of the specified contentAttributeType. </summary>
		public virtual void WriteUserDefinedContent(System.Xml.XmlWriter writer, System.Reflection.MemberInfo memberInfo, System.Type contentAttributeType, BaseAttribute parentAttribute)
		{
		}
		
		/// <summary> Write a HibernateMapping XML Element from attributes in a type. </summary>
		public virtual void WriteHibernateMapping(System.Xml.XmlWriter writer, System.Type type)
		{
			object[] attributes = type.GetCustomAttributes(typeof(HibernateMappingAttribute), false);
			if(attributes.Length == 0)
				return;
			HibernateMappingAttribute attribute = attributes[0] as HibernateMappingAttribute;

			writer.WriteStartElement( "hibernate-mapping" );
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <default-cascade>
			if(attribute.DefaultCascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("default-cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.DefaultCascade));
			// Attribute: <default-access>
			if(attribute.DefaultAccess != null)
			writer.WriteAttributeString("default-access", attribute.DefaultAccess);
			// Attribute: <auto-import>
			if( attribute.AutoImportSpecified )
			writer.WriteAttributeString("auto-import", attribute.AutoImport ? "true" : "false");
			// Attribute: <namespace>
			if(attribute.Namespace != null)
			writer.WriteAttributeString("namespace", attribute.Namespace);
			// Attribute: <assembly>
			if(attribute.Assembly != null)
			writer.WriteAttributeString("assembly", attribute.Assembly);
			// Attribute: <default-lazy>
			if( attribute.DefaultLazySpecified )
			writer.WriteAttributeString("default-lazy", attribute.DefaultLazy ? "true" : "false");
			
			WriteUserDefinedContent(writer, type, null, attribute);
			// Element: <meta>
			System.Collections.ArrayList MetaList = FindAttributedMembers( attribute, typeof(MetaAttribute), type );
			foreach( System.Reflection.MemberInfo member in MetaList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MetaAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MetaAttribute), attribute);
			// Element: <import>
			System.Collections.ArrayList ImportList = FindAttributedMembers( attribute, typeof(ImportAttribute), type );
			foreach( System.Reflection.MemberInfo member in ImportList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ImportAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteImport(writer, member, memberAttrib as ImportAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ImportAttribute), attribute);
			// Element: <class>
			WriteNestedClassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(ClassAttribute), attribute);
			// Element: <subclass>
			WriteNestedSubclassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(SubclassAttribute), attribute);
			// Element: <joined-subclass>
			WriteNestedJoinedSubclassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(JoinedSubclassAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write HibernateMapping XML Elements from nested mapped classes in a not-mapped class. </summary>
		public virtual void WriteNestedHibernateMappingTypes(System.Xml.XmlWriter writer, System.Type type)
		{
			foreach(System.Type nestedType in type.GetNestedTypes(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic))
			{
				if(nestedType.GetCustomAttributes(typeof(ClassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(HibernateMappingAttribute), false).Length == 0)
					WriteNestedHibernateMappingTypes(writer, nestedType); // Not mapped (try its nested types)
				else // Mapped
					WriteHibernateMapping(writer, nestedType);
			}
		}
		
		/// <summary> Write a Import XML Element from attributes in a member. </summary>
		public virtual void WriteImport(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ImportAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "import" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_Import_Class_DefaultValue(member) : attribute.Class);
			// Attribute: <rename>
			if(attribute.Rename != null)
			writer.WriteAttributeString("rename", attribute.Rename);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Class XML Element from attributes in a type. </summary>
		public virtual void WriteClass(System.Xml.XmlWriter writer, System.Type type)
		{
			object[] attributes = type.GetCustomAttributes(typeof(ClassAttribute), false);
			if(attributes.Length == 0)
				return;
			ClassAttribute attribute = attributes[0] as ClassAttribute;

			writer.WriteStartElement( "class" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Class_Name_DefaultValue(type) : attribute.Name);
			// Attribute: <proxy>
			if(attribute.Proxy != null)
			writer.WriteAttributeString("proxy", attribute.Proxy);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <dynamic-update>
			if( attribute.DynamicUpdateSpecified )
			writer.WriteAttributeString("dynamic-update", attribute.DynamicUpdate ? "true" : "false");
			// Attribute: <dynamic-insert>
			if( attribute.DynamicInsertSpecified )
			writer.WriteAttributeString("dynamic-insert", attribute.DynamicInsert ? "true" : "false");
			// Attribute: <select-before-update>
			if( attribute.SelectBeforeUpdateSpecified )
			writer.WriteAttributeString("select-before-update", attribute.SelectBeforeUpdate ? "true" : "false");
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <discriminator-value>
			if(attribute.DiscriminatorValue != null)
			writer.WriteAttributeString("discriminator-value", attribute.DiscriminatorValue);
			// Attribute: <mutable>
			if( attribute.MutableSpecified )
			writer.WriteAttributeString("mutable", attribute.Mutable ? "true" : "false");
			// Attribute: <polymorphism>
			if(attribute.Polymorphism != PolymorphismType.Unspecified)
			writer.WriteAttributeString("polymorphism", GetXmlEnumValue(typeof(PolymorphismType), attribute.Polymorphism));
			// Attribute: <persister>
			if(attribute.Persister != null)
			writer.WriteAttributeString("persister", attribute.Persister);
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			// Attribute: <batch-size>
			if(attribute.BatchSize != -1)
			writer.WriteAttributeString("batch-size", attribute.BatchSize.ToString());
			// Attribute: <optimistic-lock>
			if(attribute.OptimisticLock != OptimisticLockMode.Unspecified)
			writer.WriteAttributeString("optimistic-lock", GetXmlEnumValue(typeof(OptimisticLockMode), attribute.OptimisticLock));
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			
			WriteUserDefinedContent(writer, type, null, attribute);
			// Element: <meta>
			System.Collections.ArrayList MetaList = FindAttributedMembers( attribute, typeof(MetaAttribute), type );
			foreach( System.Reflection.MemberInfo member in MetaList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MetaAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			System.Collections.ArrayList JcsCacheList = FindAttributedMembers( attribute, typeof(JcsCacheAttribute), type );
			foreach( System.Reflection.MemberInfo member in JcsCacheList )
			{
				object[] objects = member.GetCustomAttributes(typeof(JcsCacheAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			System.Collections.ArrayList CacheList = FindAttributedMembers( attribute, typeof(CacheAttribute), type );
			foreach( System.Reflection.MemberInfo member in CacheList )
			{
				object[] objects = member.GetCustomAttributes(typeof(CacheAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(CacheAttribute), attribute);
			// Element: <id>
			System.Collections.ArrayList IdList = FindAttributedMembers( attribute, typeof(IdAttribute), type );
			foreach( System.Reflection.MemberInfo member in IdList )
			{
				object[] objects = member.GetCustomAttributes(typeof(IdAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteId(writer, member, memberAttrib as IdAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(IdAttribute), attribute);
			// Element: <composite-id>
			System.Collections.ArrayList CompositeIdList = FindAttributedMembers( attribute, typeof(CompositeIdAttribute), type );
			foreach( System.Reflection.MemberInfo member in CompositeIdList )
			{
				object[] objects = member.GetCustomAttributes(typeof(CompositeIdAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteCompositeId(writer, member, memberAttrib as CompositeIdAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(CompositeIdAttribute), attribute);
			// Element: <discriminator>
			System.Collections.ArrayList DiscriminatorList = FindAttributedMembers( attribute, typeof(DiscriminatorAttribute), type );
			foreach( System.Reflection.MemberInfo member in DiscriminatorList )
			{
				object[] objects = member.GetCustomAttributes(typeof(DiscriminatorAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteDiscriminator(writer, member, memberAttrib as DiscriminatorAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(DiscriminatorAttribute), attribute);
			// Element: <version>
			System.Collections.ArrayList VersionList = FindAttributedMembers( attribute, typeof(VersionAttribute), type );
			foreach( System.Reflection.MemberInfo member in VersionList )
			{
				object[] objects = member.GetCustomAttributes(typeof(VersionAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteVersion(writer, member, memberAttrib as VersionAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(VersionAttribute), attribute);
			// Element: <timestamp>
			System.Collections.ArrayList TimestampList = FindAttributedMembers( attribute, typeof(TimestampAttribute), type );
			foreach( System.Reflection.MemberInfo member in TimestampList )
			{
				object[] objects = member.GetCustomAttributes(typeof(TimestampAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteTimestamp(writer, member, memberAttrib as TimestampAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(TimestampAttribute), attribute);
			// Element: <property>
			System.Collections.ArrayList PropertyList = FindAttributedMembers( attribute, typeof(PropertyAttribute), type );
			foreach( System.Reflection.MemberInfo member in PropertyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PropertyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			System.Collections.ArrayList ManyToOneList = FindAttributedMembers( attribute, typeof(ManyToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in ManyToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ManyToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ManyToOneAttribute), attribute);
			// Element: <one-to-one>
			System.Collections.ArrayList OneToOneList = FindAttributedMembers( attribute, typeof(OneToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in OneToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(OneToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteOneToOne(writer, member, memberAttrib as OneToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(OneToOneAttribute), attribute);
			// Element: <component>
			WriteNestedComponentTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(ComponentAttribute), attribute);
			// Element: <dynamic-component>
			System.Collections.ArrayList DynamicComponentList = FindAttributedMembers( attribute, typeof(DynamicComponentAttribute), type );
			foreach( System.Reflection.MemberInfo member in DynamicComponentList )
			{
				object[] objects = member.GetCustomAttributes(typeof(DynamicComponentAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				WriteDynamicComponent(writer, member, memberAttribs[0] as DynamicComponentAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(DynamicComponentAttribute), attribute);
			// Element: <any>
			System.Collections.ArrayList AnyList = FindAttributedMembers( attribute, typeof(AnyAttribute), type );
			foreach( System.Reflection.MemberInfo member in AnyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(AnyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteAny(writer, member, memberAttrib as AnyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(AnyAttribute), attribute);
			// Element: <map>
			System.Collections.ArrayList MapList = FindAttributedMembers( attribute, typeof(MapAttribute), type );
			foreach( System.Reflection.MemberInfo member in MapList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MapAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMap(writer, member, memberAttrib as MapAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MapAttribute), attribute);
			// Element: <set>
			System.Collections.ArrayList SetList = FindAttributedMembers( attribute, typeof(SetAttribute), type );
			foreach( System.Reflection.MemberInfo member in SetList )
			{
				object[] objects = member.GetCustomAttributes(typeof(SetAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteSet(writer, member, memberAttrib as SetAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(SetAttribute), attribute);
			// Element: <list>
			System.Collections.ArrayList ListList = FindAttributedMembers( attribute, typeof(ListAttribute), type );
			foreach( System.Reflection.MemberInfo member in ListList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ListAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteList(writer, member, memberAttrib as ListAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ListAttribute), attribute);
			// Element: <bag>
			System.Collections.ArrayList BagList = FindAttributedMembers( attribute, typeof(BagAttribute), type );
			foreach( System.Reflection.MemberInfo member in BagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(BagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteBag(writer, member, memberAttrib as BagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(BagAttribute), attribute);
			// Element: <idbag>
			System.Collections.ArrayList IdBagList = FindAttributedMembers( attribute, typeof(IdBagAttribute), type );
			foreach( System.Reflection.MemberInfo member in IdBagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(IdBagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteIdBag(writer, member, memberAttrib as IdBagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(IdBagAttribute), attribute);
			// Element: <array>
			System.Collections.ArrayList ArrayList = FindAttributedMembers( attribute, typeof(ArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in ArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteArray(writer, member, memberAttrib as ArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ArrayAttribute), attribute);
			// Element: <primitive-array>
			System.Collections.ArrayList PrimitiveArrayList = FindAttributedMembers( attribute, typeof(PrimitiveArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in PrimitiveArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PrimitiveArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WritePrimitiveArray(writer, member, memberAttrib as PrimitiveArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PrimitiveArrayAttribute), attribute);
			// Element: <subclass>
			WriteNestedSubclassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(SubclassAttribute), attribute);
			// Element: <joined-subclass>
			WriteNestedJoinedSubclassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(JoinedSubclassAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write Class XML Elements from nested mapped classes in a not-mapped class. </summary>
		public virtual void WriteNestedClassTypes(System.Xml.XmlWriter writer, System.Type type)
		{
			foreach(System.Type nestedType in type.GetNestedTypes(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic))
			{
				if(nestedType.GetCustomAttributes(typeof(ClassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(ClassAttribute), false).Length == 0)
					WriteNestedClassTypes(writer, nestedType); // Not mapped (try its nested types)
				else // Mapped
					WriteClass(writer, nestedType);
			}
		}
		
		/// <summary> Write a Id XML Element from attributes in a member. </summary>
		public virtual void WriteId(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, IdAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "id" );
			// Attribute: <name>
			if(attribute.Name != null)
			writer.WriteAttributeString("name", attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <type>
			if(attribute.Type != null)
			writer.WriteAttributeString("type", attribute.Type);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			// Attribute: <unsaved-value>
			if(attribute.UnsavedValue != null)
			writer.WriteAttributeString("unsaved-value", attribute.UnsavedValue);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the IdAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is IdAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdAttribute )
						break; // Following attributes are for this Id
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdAttribute )
						break; // Following attributes are for this Id
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			// Element: <generator>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(GeneratorAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdAttribute )
						break; // Following attributes are for this Id
					if( memberAttrib is GeneratorAttribute )
						WriteGenerator(writer, member, memberAttrib as GeneratorAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(GeneratorAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a CompositeId XML Element from attributes in a member. </summary>
		public virtual void WriteCompositeId(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, CompositeIdAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "composite-id" );
			// Attribute: <class>
			if(attribute.Class != null)
			writer.WriteAttributeString("class", attribute.Class);
			// Attribute: <name>
			if(attribute.Name != null)
			writer.WriteAttributeString("name", attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <unsaved-value>
			if(attribute.UnsavedValue != UnsavedValueType.Unspecified)
			writer.WriteAttributeString("unsaved-value", GetXmlEnumValue(typeof(UnsavedValueType), attribute.UnsavedValue));
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the CompositeIdAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is CompositeIdAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <key-property>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyPropertyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeIdAttribute )
						break; // Following attributes are for this CompositeId
					if( memberAttrib is KeyPropertyAttribute )
						WriteKeyProperty(writer, member, memberAttrib as KeyPropertyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyPropertyAttribute), attribute);
			// Element: <key-many-to-one>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyManyToOneAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeIdAttribute )
						break; // Following attributes are for this CompositeId
					if( memberAttrib is KeyManyToOneAttribute )
						WriteKeyManyToOne(writer, member, memberAttrib as KeyManyToOneAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyManyToOneAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Discriminator XML Element from attributes in a member. </summary>
		public virtual void WriteDiscriminator(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, DiscriminatorAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "discriminator" );
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <type>
			if(attribute.Type != null)
			writer.WriteAttributeString("type", attribute.Type);
			// Attribute: <not-null>
			if( attribute.NotNullSpecified )
			writer.WriteAttributeString("not-null", attribute.NotNull ? "true" : "false");
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			// Attribute: <force>
			if( attribute.ForceSpecified )
			writer.WriteAttributeString("force", attribute.Force ? "true" : "false");
			// Attribute: <insert>
			if( attribute.InsertSpecified )
			writer.WriteAttributeString("insert", attribute.Insert ? "true" : "false");
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the DiscriminatorAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is DiscriminatorAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DiscriminatorAttribute )
						break; // Following attributes are for this Discriminator
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Version XML Element from attributes in a member. </summary>
		public virtual void WriteVersion(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, VersionAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "version" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Version_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <type>
			if(attribute.Type != null)
			writer.WriteAttributeString("type", attribute.Type);
			// Attribute: <unsaved-value>
			if(attribute.UnsavedValue != null)
			writer.WriteAttributeString("unsaved-value", attribute.UnsavedValue);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Timestamp XML Element from attributes in a member. </summary>
		public virtual void WriteTimestamp(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, TimestampAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "timestamp" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Timestamp_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <unsaved-value>
			if(attribute.UnsavedValue != null)
			writer.WriteAttributeString("unsaved-value", attribute.UnsavedValue);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Subclass XML Element from attributes in a type. </summary>
		public virtual void WriteSubclass(System.Xml.XmlWriter writer, System.Type type)
		{
			object[] attributes = type.GetCustomAttributes(typeof(SubclassAttribute), false);
			if(attributes.Length == 0)
				return;
			SubclassAttribute attribute = attributes[0] as SubclassAttribute;

			writer.WriteStartElement( "subclass" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Subclass_Name_DefaultValue(type) : attribute.Name);
			// Attribute: <proxy>
			if(attribute.Proxy != null)
			writer.WriteAttributeString("proxy", attribute.Proxy);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <dynamic-update>
			if( attribute.DynamicUpdateSpecified )
			writer.WriteAttributeString("dynamic-update", attribute.DynamicUpdate ? "true" : "false");
			// Attribute: <dynamic-insert>
			if( attribute.DynamicInsertSpecified )
			writer.WriteAttributeString("dynamic-insert", attribute.DynamicInsert ? "true" : "false");
			// Attribute: <select-before-update>
			if( attribute.SelectBeforeUpdateSpecified )
			writer.WriteAttributeString("select-before-update", attribute.SelectBeforeUpdate ? "true" : "false");
			// Attribute: <extends>
			if(attribute.Extends != null)
			writer.WriteAttributeString("extends", attribute.Extends);
			// Attribute: <discriminator-value>
			if(attribute.DiscriminatorValue != null)
			writer.WriteAttributeString("discriminator-value", attribute.DiscriminatorValue);
			
			WriteUserDefinedContent(writer, type, null, attribute);
			// Element: <meta>
			System.Collections.ArrayList MetaList = FindAttributedMembers( attribute, typeof(MetaAttribute), type );
			foreach( System.Reflection.MemberInfo member in MetaList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MetaAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MetaAttribute), attribute);
			// Element: <property>
			System.Collections.ArrayList PropertyList = FindAttributedMembers( attribute, typeof(PropertyAttribute), type );
			foreach( System.Reflection.MemberInfo member in PropertyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PropertyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			System.Collections.ArrayList ManyToOneList = FindAttributedMembers( attribute, typeof(ManyToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in ManyToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ManyToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ManyToOneAttribute), attribute);
			// Element: <one-to-one>
			System.Collections.ArrayList OneToOneList = FindAttributedMembers( attribute, typeof(OneToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in OneToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(OneToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteOneToOne(writer, member, memberAttrib as OneToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(OneToOneAttribute), attribute);
			// Element: <component>
			WriteNestedComponentTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(ComponentAttribute), attribute);
			// Element: <dynamic-component>
			System.Collections.ArrayList DynamicComponentList = FindAttributedMembers( attribute, typeof(DynamicComponentAttribute), type );
			foreach( System.Reflection.MemberInfo member in DynamicComponentList )
			{
				object[] objects = member.GetCustomAttributes(typeof(DynamicComponentAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				WriteDynamicComponent(writer, member, memberAttribs[0] as DynamicComponentAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(DynamicComponentAttribute), attribute);
			// Element: <any>
			System.Collections.ArrayList AnyList = FindAttributedMembers( attribute, typeof(AnyAttribute), type );
			foreach( System.Reflection.MemberInfo member in AnyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(AnyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteAny(writer, member, memberAttrib as AnyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(AnyAttribute), attribute);
			// Element: <map>
			System.Collections.ArrayList MapList = FindAttributedMembers( attribute, typeof(MapAttribute), type );
			foreach( System.Reflection.MemberInfo member in MapList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MapAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMap(writer, member, memberAttrib as MapAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MapAttribute), attribute);
			// Element: <set>
			System.Collections.ArrayList SetList = FindAttributedMembers( attribute, typeof(SetAttribute), type );
			foreach( System.Reflection.MemberInfo member in SetList )
			{
				object[] objects = member.GetCustomAttributes(typeof(SetAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteSet(writer, member, memberAttrib as SetAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(SetAttribute), attribute);
			// Element: <list>
			System.Collections.ArrayList ListList = FindAttributedMembers( attribute, typeof(ListAttribute), type );
			foreach( System.Reflection.MemberInfo member in ListList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ListAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteList(writer, member, memberAttrib as ListAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ListAttribute), attribute);
			// Element: <bag>
			System.Collections.ArrayList BagList = FindAttributedMembers( attribute, typeof(BagAttribute), type );
			foreach( System.Reflection.MemberInfo member in BagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(BagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteBag(writer, member, memberAttrib as BagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(BagAttribute), attribute);
			// Element: <idbag>
			System.Collections.ArrayList IdBagList = FindAttributedMembers( attribute, typeof(IdBagAttribute), type );
			foreach( System.Reflection.MemberInfo member in IdBagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(IdBagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteIdBag(writer, member, memberAttrib as IdBagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(IdBagAttribute), attribute);
			// Element: <array>
			System.Collections.ArrayList ArrayList = FindAttributedMembers( attribute, typeof(ArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in ArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteArray(writer, member, memberAttrib as ArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ArrayAttribute), attribute);
			// Element: <primitive-array>
			System.Collections.ArrayList PrimitiveArrayList = FindAttributedMembers( attribute, typeof(PrimitiveArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in PrimitiveArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PrimitiveArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WritePrimitiveArray(writer, member, memberAttrib as PrimitiveArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PrimitiveArrayAttribute), attribute);
			// Element: <subclass>
			WriteNestedSubclassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(SubclassAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write Subclass XML Elements from nested mapped classes in a not-mapped class. </summary>
		public virtual void WriteNestedSubclassTypes(System.Xml.XmlWriter writer, System.Type type)
		{
			foreach(System.Type nestedType in type.GetNestedTypes(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic))
			{
				if(nestedType.GetCustomAttributes(typeof(ClassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(SubclassAttribute), false).Length == 0)
					WriteNestedSubclassTypes(writer, nestedType); // Not mapped (try its nested types)
				else // Mapped
					WriteSubclass(writer, nestedType);
			}
		}
		
		/// <summary> Write a JoinedSubclass XML Element from attributes in a type. </summary>
		public virtual void WriteJoinedSubclass(System.Xml.XmlWriter writer, System.Type type)
		{
			object[] attributes = type.GetCustomAttributes(typeof(JoinedSubclassAttribute), false);
			if(attributes.Length == 0)
				return;
			JoinedSubclassAttribute attribute = attributes[0] as JoinedSubclassAttribute;

			writer.WriteStartElement( "joined-subclass" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_JoinedSubclass_Name_DefaultValue(type) : attribute.Name);
			// Attribute: <proxy>
			if(attribute.Proxy != null)
			writer.WriteAttributeString("proxy", attribute.Proxy);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <dynamic-update>
			if( attribute.DynamicUpdateSpecified )
			writer.WriteAttributeString("dynamic-update", attribute.DynamicUpdate ? "true" : "false");
			// Attribute: <dynamic-insert>
			if( attribute.DynamicInsertSpecified )
			writer.WriteAttributeString("dynamic-insert", attribute.DynamicInsert ? "true" : "false");
			// Attribute: <select-before-update>
			if( attribute.SelectBeforeUpdateSpecified )
			writer.WriteAttributeString("select-before-update", attribute.SelectBeforeUpdate ? "true" : "false");
			// Attribute: <extends>
			if(attribute.Extends != null)
			writer.WriteAttributeString("extends", attribute.Extends);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			
			WriteUserDefinedContent(writer, type, null, attribute);
			// Element: <meta>
			System.Collections.ArrayList MetaList = FindAttributedMembers( attribute, typeof(MetaAttribute), type );
			foreach( System.Reflection.MemberInfo member in MetaList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MetaAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MetaAttribute), attribute);
			// Element: <key>
			System.Collections.ArrayList KeyList = FindAttributedMembers( attribute, typeof(KeyAttribute), type );
			foreach( System.Reflection.MemberInfo member in KeyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(KeyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(KeyAttribute), attribute);
			// Element: <property>
			System.Collections.ArrayList PropertyList = FindAttributedMembers( attribute, typeof(PropertyAttribute), type );
			foreach( System.Reflection.MemberInfo member in PropertyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PropertyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			System.Collections.ArrayList ManyToOneList = FindAttributedMembers( attribute, typeof(ManyToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in ManyToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ManyToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ManyToOneAttribute), attribute);
			// Element: <one-to-one>
			System.Collections.ArrayList OneToOneList = FindAttributedMembers( attribute, typeof(OneToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in OneToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(OneToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteOneToOne(writer, member, memberAttrib as OneToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(OneToOneAttribute), attribute);
			// Element: <component>
			WriteNestedComponentTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(ComponentAttribute), attribute);
			// Element: <dynamic-component>
			System.Collections.ArrayList DynamicComponentList = FindAttributedMembers( attribute, typeof(DynamicComponentAttribute), type );
			foreach( System.Reflection.MemberInfo member in DynamicComponentList )
			{
				object[] objects = member.GetCustomAttributes(typeof(DynamicComponentAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				WriteDynamicComponent(writer, member, memberAttribs[0] as DynamicComponentAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(DynamicComponentAttribute), attribute);
			// Element: <any>
			System.Collections.ArrayList AnyList = FindAttributedMembers( attribute, typeof(AnyAttribute), type );
			foreach( System.Reflection.MemberInfo member in AnyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(AnyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteAny(writer, member, memberAttrib as AnyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(AnyAttribute), attribute);
			// Element: <map>
			System.Collections.ArrayList MapList = FindAttributedMembers( attribute, typeof(MapAttribute), type );
			foreach( System.Reflection.MemberInfo member in MapList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MapAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMap(writer, member, memberAttrib as MapAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MapAttribute), attribute);
			// Element: <set>
			System.Collections.ArrayList SetList = FindAttributedMembers( attribute, typeof(SetAttribute), type );
			foreach( System.Reflection.MemberInfo member in SetList )
			{
				object[] objects = member.GetCustomAttributes(typeof(SetAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteSet(writer, member, memberAttrib as SetAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(SetAttribute), attribute);
			// Element: <list>
			System.Collections.ArrayList ListList = FindAttributedMembers( attribute, typeof(ListAttribute), type );
			foreach( System.Reflection.MemberInfo member in ListList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ListAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteList(writer, member, memberAttrib as ListAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ListAttribute), attribute);
			// Element: <bag>
			System.Collections.ArrayList BagList = FindAttributedMembers( attribute, typeof(BagAttribute), type );
			foreach( System.Reflection.MemberInfo member in BagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(BagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteBag(writer, member, memberAttrib as BagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(BagAttribute), attribute);
			// Element: <idbag>
			System.Collections.ArrayList IdBagList = FindAttributedMembers( attribute, typeof(IdBagAttribute), type );
			foreach( System.Reflection.MemberInfo member in IdBagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(IdBagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteIdBag(writer, member, memberAttrib as IdBagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(IdBagAttribute), attribute);
			// Element: <array>
			System.Collections.ArrayList ArrayList = FindAttributedMembers( attribute, typeof(ArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in ArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteArray(writer, member, memberAttrib as ArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ArrayAttribute), attribute);
			// Element: <primitive-array>
			System.Collections.ArrayList PrimitiveArrayList = FindAttributedMembers( attribute, typeof(PrimitiveArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in PrimitiveArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PrimitiveArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WritePrimitiveArray(writer, member, memberAttrib as PrimitiveArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PrimitiveArrayAttribute), attribute);
			// Element: <joined-subclass>
			WriteNestedJoinedSubclassTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(JoinedSubclassAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write JoinedSubclass XML Elements from nested mapped classes in a not-mapped class. </summary>
		public virtual void WriteNestedJoinedSubclassTypes(System.Xml.XmlWriter writer, System.Type type)
		{
			foreach(System.Type nestedType in type.GetNestedTypes(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic))
			{
				if(nestedType.GetCustomAttributes(typeof(ClassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(JoinedSubclassAttribute), false).Length == 0)
					WriteNestedJoinedSubclassTypes(writer, nestedType); // Not mapped (try its nested types)
				else // Mapped
					WriteJoinedSubclass(writer, nestedType);
			}
		}
		
		/// <summary> Write a Property XML Element from attributes in a member. </summary>
		public virtual void WriteProperty(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, PropertyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "property" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Property_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <type>
			if(attribute.Type != null)
			writer.WriteAttributeString("type", attribute.Type);
			else
			{
				System.Type type = null;
				if(member is System.Reflection.PropertyInfo)
					type = (member as System.Reflection.PropertyInfo).PropertyType;
				else if(member is System.Reflection.FieldInfo)
					type = (member as System.Reflection.FieldInfo).FieldType;
				if(type != null) // Transform using RegularExpressions
				{
					string typeName = type.FullName + ", " + type.Assembly.GetName().Name;
					foreach(System.Collections.DictionaryEntry pattern in Patterns)
					{
						if(System.Text.RegularExpressions.Regex.IsMatch(typeName, pattern.Key as string))
						{
							writer.WriteAttributeString( "type",
								System.Text.RegularExpressions.Regex.Replace(typeName,
									pattern.Key as string,
									pattern.Value as string) );
							break;
						}
					}
				}
			}
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			// Attribute: <not-null>
			if( attribute.NotNullSpecified )
			writer.WriteAttributeString("not-null", attribute.NotNull ? "true" : "false");
			// Attribute: <unique>
			if( attribute.UniqueSpecified )
			writer.WriteAttributeString("unique", attribute.Unique ? "true" : "false");
			// Attribute: <update>
			if( attribute.UpdateSpecified )
			writer.WriteAttributeString("update", attribute.Update ? "true" : "false");
			// Attribute: <insert>
			if( attribute.InsertSpecified )
			writer.WriteAttributeString("insert", attribute.Insert ? "true" : "false");
			// Attribute: <formula>
			if(attribute.Formula != null)
			writer.WriteAttributeString("formula", attribute.Formula);
			// Attribute: <index>
			if(attribute.Index != null)
			writer.WriteAttributeString("index", attribute.Index);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the PropertyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is PropertyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PropertyAttribute )
						break; // Following attributes are for this Property
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PropertyAttribute )
						break; // Following attributes are for this Property
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			// Element: <type>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(TypeAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PropertyAttribute )
						break; // Following attributes are for this Property
					if( memberAttrib is TypeAttribute )
						WriteType(writer, member, memberAttrib as TypeAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(TypeAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a MetaValue XML Element from attributes in a member. </summary>
		public virtual void WriteMetaValue(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, MetaValueAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "meta-value" );
			// Attribute: <value>
			writer.WriteAttributeString("value", attribute.Value==null ? DefaultHelper.Get_MetaValue_Value_DefaultValue(member) : attribute.Value);
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_MetaValue_Class_DefaultValue(member) : attribute.Class);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Any XML Element from attributes in a member. </summary>
		public virtual void WriteAny(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, AnyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "any" );
			// Attribute: <id-type>
			writer.WriteAttributeString("id-type", attribute.IdType==null ? DefaultHelper.Get_Any_IdType_DefaultValue(member) : attribute.IdType);
			// Attribute: <meta-type>
			if(attribute.MetaType != null)
			writer.WriteAttributeString("meta-type", attribute.MetaType);
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Any_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <insert>
			if( attribute.InsertSpecified )
			writer.WriteAttributeString("insert", attribute.Insert ? "true" : "false");
			// Attribute: <update>
			if( attribute.UpdateSpecified )
			writer.WriteAttributeString("update", attribute.Update ? "true" : "false");
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <index>
			if(attribute.Index != null)
			writer.WriteAttributeString("index", attribute.Index);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the AnyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is AnyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is AnyAttribute )
						break; // Following attributes are for this Any
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <meta-value>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaValueAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is AnyAttribute )
						break; // Following attributes are for this Any
					if( memberAttrib is MetaValueAttribute )
						WriteMetaValue(writer, member, memberAttrib as MetaValueAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaValueAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is AnyAttribute )
						break; // Following attributes are for this Any
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Array XML Element from attributes in a member. </summary>
		public virtual void WriteArray(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ArrayAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "array" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Array_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <element-class>
			if(attribute.ElementClass != null)
			writer.WriteAttributeString("element-class", attribute.ElementClass);
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the ArrayAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is ArrayAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <index>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(IndexAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is IndexAttribute )
						WriteIndex(writer, member, memberAttrib as IndexAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(IndexAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			// Element: <one-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(OneToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is OneToManyAttribute )
						WriteOneToMany(writer, member, memberAttrib as OneToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(OneToManyAttribute), attribute);
			// Element: <many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is ManyToManyAttribute )
						WriteManyToMany(writer, member, memberAttrib as ManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToManyAttribute), attribute);
			// Element: <composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is CompositeElementAttribute )
						WriteCompositeElement(writer, member, memberAttrib as CompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeElementAttribute), attribute);
			// Element: <many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ArrayAttribute )
						break; // Following attributes are for this Array
					if( memberAttrib is ManyToAnyAttribute )
						WriteManyToAny(writer, member, memberAttrib as ManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToAnyAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Cache XML Element from attributes in a member. </summary>
		public virtual void WriteCache(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, CacheAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "cache" );
			// Attribute: <usage>
			writer.WriteAttributeString("usage", attribute.Usage==CacheUsage.Unspecified ? DefaultHelper.Get_Cache_Usage_DefaultValue(member) : GetXmlEnumValue(typeof(CacheUsage), attribute.Usage));
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a CollectionId XML Element from attributes in a member. </summary>
		public virtual void WriteCollectionId(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, CollectionIdAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "collection-id" );
			// Attribute: <column>
			writer.WriteAttributeString("column", attribute.Column==null ? DefaultHelper.Get_CollectionId_Column_DefaultValue(member) : attribute.Column);
			// Attribute: <type>
			writer.WriteAttributeString("type", attribute.Type==null ? DefaultHelper.Get_CollectionId_Type_DefaultValue(member) : attribute.Type);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the CollectionIdAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is CollectionIdAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CollectionIdAttribute )
						break; // Following attributes are for this CollectionId
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CollectionIdAttribute )
						break; // Following attributes are for this CollectionId
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			// Element: <generator>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(GeneratorAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CollectionIdAttribute )
						break; // Following attributes are for this CollectionId
					if( memberAttrib is GeneratorAttribute )
						WriteGenerator(writer, member, memberAttrib as GeneratorAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(GeneratorAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Column XML Element from attributes in a member. </summary>
		public virtual void WriteColumn(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ColumnAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "column" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Column_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			// Attribute: <not-null>
			if( attribute.NotNullSpecified )
			writer.WriteAttributeString("not-null", attribute.NotNull ? "true" : "false");
			// Attribute: <unique>
			if( attribute.UniqueSpecified )
			writer.WriteAttributeString("unique", attribute.Unique ? "true" : "false");
			// Attribute: <unique-key>
			if(attribute.UniqueKey != null)
			writer.WriteAttributeString("unique-key", attribute.UniqueKey);
			// Attribute: <sql-type>
			if(attribute.SqlType != null)
			writer.WriteAttributeString("sql-type", attribute.SqlType);
			// Attribute: <index>
			if(attribute.Index != null)
			writer.WriteAttributeString("index", attribute.Index);
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Component XML Element from attributes in a type. </summary>
		public virtual void WriteComponent(System.Xml.XmlWriter writer, System.Type type)
		{
			object[] attributes = type.GetCustomAttributes(typeof(ComponentAttribute), false);
			if(attributes.Length == 0)
				return;
			ComponentAttribute attribute = attributes[0] as ComponentAttribute;

			writer.WriteStartElement( "component" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Component_Name_DefaultValue(type) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <class>
			if(attribute.Class != null)
			writer.WriteAttributeString("class", attribute.Class);
			// Attribute: <update>
			if( attribute.UpdateSpecified )
			writer.WriteAttributeString("update", attribute.Update ? "true" : "false");
			// Attribute: <insert>
			if( attribute.InsertSpecified )
			writer.WriteAttributeString("insert", attribute.Insert ? "true" : "false");
			
			WriteUserDefinedContent(writer, type, null, attribute);
			// Element: <parent>
			System.Collections.ArrayList ParentList = FindAttributedMembers( attribute, typeof(ParentAttribute), type );
			foreach( System.Reflection.MemberInfo member in ParentList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ParentAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteParent(writer, member, memberAttrib as ParentAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ParentAttribute), attribute);
			// Element: <property>
			System.Collections.ArrayList PropertyList = FindAttributedMembers( attribute, typeof(PropertyAttribute), type );
			foreach( System.Reflection.MemberInfo member in PropertyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PropertyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			System.Collections.ArrayList ManyToOneList = FindAttributedMembers( attribute, typeof(ManyToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in ManyToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ManyToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ManyToOneAttribute), attribute);
			// Element: <one-to-one>
			System.Collections.ArrayList OneToOneList = FindAttributedMembers( attribute, typeof(OneToOneAttribute), type );
			foreach( System.Reflection.MemberInfo member in OneToOneList )
			{
				object[] objects = member.GetCustomAttributes(typeof(OneToOneAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteOneToOne(writer, member, memberAttrib as OneToOneAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(OneToOneAttribute), attribute);
			// Element: <component>
			WriteNestedComponentTypes(writer, type);
			WriteUserDefinedContent(writer, type, typeof(ComponentAttribute), attribute);
			// Element: <dynamic-component>
			System.Collections.ArrayList DynamicComponentList = FindAttributedMembers( attribute, typeof(DynamicComponentAttribute), type );
			foreach( System.Reflection.MemberInfo member in DynamicComponentList )
			{
				object[] objects = member.GetCustomAttributes(typeof(DynamicComponentAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				WriteDynamicComponent(writer, member, memberAttribs[0] as DynamicComponentAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(DynamicComponentAttribute), attribute);
			// Element: <any>
			System.Collections.ArrayList AnyList = FindAttributedMembers( attribute, typeof(AnyAttribute), type );
			foreach( System.Reflection.MemberInfo member in AnyList )
			{
				object[] objects = member.GetCustomAttributes(typeof(AnyAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteAny(writer, member, memberAttrib as AnyAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(AnyAttribute), attribute);
			// Element: <map>
			System.Collections.ArrayList MapList = FindAttributedMembers( attribute, typeof(MapAttribute), type );
			foreach( System.Reflection.MemberInfo member in MapList )
			{
				object[] objects = member.GetCustomAttributes(typeof(MapAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteMap(writer, member, memberAttrib as MapAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(MapAttribute), attribute);
			// Element: <set>
			System.Collections.ArrayList SetList = FindAttributedMembers( attribute, typeof(SetAttribute), type );
			foreach( System.Reflection.MemberInfo member in SetList )
			{
				object[] objects = member.GetCustomAttributes(typeof(SetAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteSet(writer, member, memberAttrib as SetAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(SetAttribute), attribute);
			// Element: <list>
			System.Collections.ArrayList ListList = FindAttributedMembers( attribute, typeof(ListAttribute), type );
			foreach( System.Reflection.MemberInfo member in ListList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ListAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteList(writer, member, memberAttrib as ListAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ListAttribute), attribute);
			// Element: <bag>
			System.Collections.ArrayList BagList = FindAttributedMembers( attribute, typeof(BagAttribute), type );
			foreach( System.Reflection.MemberInfo member in BagList )
			{
				object[] objects = member.GetCustomAttributes(typeof(BagAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteBag(writer, member, memberAttrib as BagAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(BagAttribute), attribute);
			// Element: <array>
			System.Collections.ArrayList ArrayList = FindAttributedMembers( attribute, typeof(ArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in ArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(ArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WriteArray(writer, member, memberAttrib as ArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(ArrayAttribute), attribute);
			// Element: <primitive-array>
			System.Collections.ArrayList PrimitiveArrayList = FindAttributedMembers( attribute, typeof(PrimitiveArrayAttribute), type );
			foreach( System.Reflection.MemberInfo member in PrimitiveArrayList )
			{
				object[] objects = member.GetCustomAttributes(typeof(PrimitiveArrayAttribute), false);
				System.Collections.ArrayList memberAttribs = new System.Collections.ArrayList();
				memberAttribs.AddRange(objects);
				memberAttribs.Sort();
				foreach(object memberAttrib in memberAttribs)
					WritePrimitiveArray(writer, member, memberAttrib as PrimitiveArrayAttribute, attribute);
			}
			WriteUserDefinedContent(writer, type, typeof(PrimitiveArrayAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write Component XML Elements from nested mapped classes in a not-mapped class. </summary>
		public virtual void WriteNestedComponentTypes(System.Xml.XmlWriter writer, System.Type type)
		{
			foreach(System.Type nestedType in type.GetNestedTypes(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic))
			{
				if(nestedType.GetCustomAttributes(typeof(ClassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(SubclassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(JoinedSubclassAttribute), false).Length != 0)
					continue;
				if(nestedType.GetCustomAttributes(typeof(ComponentAttribute), false).Length == 0)
					WriteNestedComponentTypes(writer, nestedType); // Not mapped (try its nested types)
				else // Mapped
					WriteComponent(writer, nestedType);
			}
		}
		
		/// <summary> Write a DynamicComponent XML Element from attributes in a member. </summary>
		public virtual void WriteDynamicComponent(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, DynamicComponentAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "dynamic-component" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_DynamicComponent_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <update>
			if( attribute.UpdateSpecified )
			writer.WriteAttributeString("update", attribute.Update ? "true" : "false");
			// Attribute: <insert>
			if( attribute.InsertSpecified )
			writer.WriteAttributeString("insert", attribute.Insert ? "true" : "false");
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the DynamicComponentAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is DynamicComponentAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <property>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(PropertyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is PropertyAttribute )
						WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToOneAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is ManyToOneAttribute )
						WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToOneAttribute), attribute);
			// Element: <one-to-one>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(OneToOneAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is OneToOneAttribute )
						WriteOneToOne(writer, member, memberAttrib as OneToOneAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(OneToOneAttribute), attribute);
			// Element: <component>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ComponentAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
			}
			WriteUserDefinedContent(writer, member, typeof(ComponentAttribute), attribute);
			// Element: <dynamic-component>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(DynamicComponentAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						WriteDynamicComponent(writer, member, memberAttrib as DynamicComponentAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(DynamicComponentAttribute), attribute);
			// Element: <any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(AnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is AnyAttribute )
						WriteAny(writer, member, memberAttrib as AnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(AnyAttribute), attribute);
			// Element: <map>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MapAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is MapAttribute )
						WriteMap(writer, member, memberAttrib as MapAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MapAttribute), attribute);
			// Element: <set>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(SetAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is SetAttribute )
						WriteSet(writer, member, memberAttrib as SetAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(SetAttribute), attribute);
			// Element: <list>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ListAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is ListAttribute )
						WriteList(writer, member, memberAttrib as ListAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ListAttribute), attribute);
			// Element: <bag>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(BagAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is BagAttribute )
						WriteBag(writer, member, memberAttrib as BagAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(BagAttribute), attribute);
			// Element: <array>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ArrayAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is ArrayAttribute )
						WriteArray(writer, member, memberAttrib as ArrayAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ArrayAttribute), attribute);
			// Element: <primitive-array>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(PrimitiveArrayAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is DynamicComponentAttribute )
						break; // Following attributes are for this DynamicComponent
					if( memberAttrib is PrimitiveArrayAttribute )
						WritePrimitiveArray(writer, member, memberAttrib as PrimitiveArrayAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(PrimitiveArrayAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a CompositeElement XML Element from attributes in a member. </summary>
		public virtual void WriteCompositeElement(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, CompositeElementAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "composite-element" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_CompositeElement_Class_DefaultValue(member) : attribute.Class);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the CompositeElementAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is CompositeElementAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <parent>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ParentAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeElementAttribute )
						break; // Following attributes are for this CompositeElement
					if( memberAttrib is ParentAttribute )
						WriteParent(writer, member, memberAttrib as ParentAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ParentAttribute), attribute);
			// Element: <property>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(PropertyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeElementAttribute )
						break; // Following attributes are for this CompositeElement
					if( memberAttrib is PropertyAttribute )
						WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToOneAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeElementAttribute )
						break; // Following attributes are for this CompositeElement
					if( memberAttrib is ManyToOneAttribute )
						WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToOneAttribute), attribute);
			// Element: <nested-composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(NestedCompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is NestedCompositeElementAttribute )
						WriteNestedCompositeElement(writer, member, memberAttrib as NestedCompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(NestedCompositeElementAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a CompositeIndex XML Element from attributes in a member. </summary>
		public virtual void WriteCompositeIndex(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, CompositeIndexAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "composite-index" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_CompositeIndex_Class_DefaultValue(member) : attribute.Class);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the CompositeIndexAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is CompositeIndexAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <key-property>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyPropertyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeIndexAttribute )
						break; // Following attributes are for this CompositeIndex
					if( memberAttrib is KeyPropertyAttribute )
						WriteKeyProperty(writer, member, memberAttrib as KeyPropertyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyPropertyAttribute), attribute);
			// Element: <key-many-to-one>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyManyToOneAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is CompositeIndexAttribute )
						break; // Following attributes are for this CompositeIndex
					if( memberAttrib is KeyManyToOneAttribute )
						WriteKeyManyToOne(writer, member, memberAttrib as KeyManyToOneAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyManyToOneAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Element XML Element from attributes in a member. </summary>
		public virtual void WriteElement(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ElementAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "element" );
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <type>
			writer.WriteAttributeString("type", attribute.Type==null ? DefaultHelper.Get_Element_Type_DefaultValue(member) : attribute.Type);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			// Attribute: <not-null>
			if( attribute.NotNullSpecified )
			writer.WriteAttributeString("not-null", attribute.NotNull ? "true" : "false");
			// Attribute: <unique>
			if( attribute.UniqueSpecified )
			writer.WriteAttributeString("unique", attribute.Unique ? "true" : "false");
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the ElementAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is ElementAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ElementAttribute )
						break; // Following attributes are for this Element
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Generator XML Element from attributes in a member. </summary>
		public virtual void WriteGenerator(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, GeneratorAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "generator" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_Generator_Class_DefaultValue(member) : attribute.Class);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the GeneratorAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is GeneratorAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <param>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ParamAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is GeneratorAttribute )
						break; // Following attributes are for this Generator
					if( memberAttrib is ParamAttribute )
						WriteParam(writer, member, memberAttrib as ParamAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ParamAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a IdBag XML Element from attributes in a member. </summary>
		public virtual void WriteIdBag(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, IdBagAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "idbag" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_IdBag_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			// Attribute: <inverse>
			if( attribute.InverseSpecified )
			writer.WriteAttributeString("inverse", attribute.Inverse ? "true" : "false");
			// Attribute: <persister>
			if(attribute.Persister != null)
			writer.WriteAttributeString("persister", attribute.Persister);
			// Attribute: <batch-size>
			if(attribute.BatchSize != -1)
			writer.WriteAttributeString("batch-size", attribute.BatchSize.ToString());
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			// Attribute: <collection-type>
			if(attribute.CollectionType != null)
			writer.WriteAttributeString("collection-type", attribute.CollectionType);
			// Attribute: <generic>
			if( attribute.GenericSpecified )
			writer.WriteAttributeString("generic", attribute.Generic ? "true" : "false");
			// Attribute: <order-by>
			if(attribute.OrderBy != null)
			writer.WriteAttributeString("order-by", attribute.OrderBy);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the IdBagAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is IdBagAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <collection-id>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CollectionIdAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is CollectionIdAttribute )
						WriteCollectionId(writer, member, memberAttrib as CollectionIdAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CollectionIdAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			// Element: <many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is ManyToManyAttribute )
						WriteManyToMany(writer, member, memberAttrib as ManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToManyAttribute), attribute);
			// Element: <composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is CompositeElementAttribute )
						WriteCompositeElement(writer, member, memberAttrib as CompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeElementAttribute), attribute);
			// Element: <many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IdBagAttribute )
						break; // Following attributes are for this IdBag
					if( memberAttrib is ManyToAnyAttribute )
						WriteManyToAny(writer, member, memberAttrib as ManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToAnyAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Index XML Element from attributes in a member. </summary>
		public virtual void WriteIndex(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, IndexAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "index" );
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <type>
			if(attribute.Type != null)
			writer.WriteAttributeString("type", attribute.Type);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the IndexAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is IndexAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IndexAttribute )
						break; // Following attributes are for this Index
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a IndexManyToAny XML Element from attributes in a member. </summary>
		public virtual void WriteIndexManyToAny(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, IndexManyToAnyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "index-many-to-any" );
			// Attribute: <id-type>
			writer.WriteAttributeString("id-type", attribute.IdType==null ? DefaultHelper.Get_IndexManyToAny_IdType_DefaultValue(member) : attribute.IdType);
			// Attribute: <meta-type>
			if(attribute.MetaType != null)
			writer.WriteAttributeString("meta-type", attribute.MetaType);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the IndexManyToAnyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is IndexManyToAnyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IndexManyToAnyAttribute )
						break; // Following attributes are for this IndexManyToAny
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a IndexManyToMany XML Element from attributes in a member. </summary>
		public virtual void WriteIndexManyToMany(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, IndexManyToManyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "index-many-to-many" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_IndexManyToMany_Class_DefaultValue(member) : attribute.Class);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <foreign-key>
			if(attribute.ForeignKey != null)
			writer.WriteAttributeString("foreign-key", attribute.ForeignKey);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the IndexManyToManyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is IndexManyToManyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is IndexManyToManyAttribute )
						break; // Following attributes are for this IndexManyToMany
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a JcsCache XML Element from attributes in a member. </summary>
		public virtual void WriteJcsCache(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, JcsCacheAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "jcs-cache" );
			// Attribute: <usage>
			writer.WriteAttributeString("usage", attribute.Usage==JcsCacheUsage.Unspecified ? DefaultHelper.Get_JcsCache_Usage_DefaultValue(member) : GetXmlEnumValue(typeof(JcsCacheUsage), attribute.Usage));
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Key XML Element from attributes in a member. </summary>
		public virtual void WriteKey(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, KeyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "key" );
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <foreign-key>
			if(attribute.ForeignKey != null)
			writer.WriteAttributeString("foreign-key", attribute.ForeignKey);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the KeyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is KeyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is KeyAttribute )
						break; // Following attributes are for this Key
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a KeyManyToOne XML Element from attributes in a member. </summary>
		public virtual void WriteKeyManyToOne(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, KeyManyToOneAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "key-many-to-one" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_KeyManyToOne_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <class>
			if(attribute.Class != null)
			writer.WriteAttributeString("class", attribute.Class);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <foreign-key>
			if(attribute.ForeignKey != null)
			writer.WriteAttributeString("foreign-key", attribute.ForeignKey);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the KeyManyToOneAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is KeyManyToOneAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is KeyManyToOneAttribute )
						break; // Following attributes are for this KeyManyToOne
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a KeyProperty XML Element from attributes in a member. </summary>
		public virtual void WriteKeyProperty(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, KeyPropertyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "key-property" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_KeyProperty_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <type>
			if(attribute.Type != null)
			writer.WriteAttributeString("type", attribute.Type);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <length>
			if(attribute.Length != -1)
			writer.WriteAttributeString("length", attribute.Length.ToString());
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the KeyPropertyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is KeyPropertyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is KeyPropertyAttribute )
						break; // Following attributes are for this KeyProperty
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a ManyToAny XML Element from attributes in a member. </summary>
		public virtual void WriteManyToAny(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ManyToAnyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "many-to-any" );
			// Attribute: <id-type>
			writer.WriteAttributeString("id-type", attribute.IdType==null ? DefaultHelper.Get_ManyToAny_IdType_DefaultValue(member) : attribute.IdType);
			// Attribute: <meta-type>
			if(attribute.MetaType != null)
			writer.WriteAttributeString("meta-type", attribute.MetaType);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the ManyToAnyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is ManyToAnyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta-value>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaValueAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ManyToAnyAttribute )
						break; // Following attributes are for this ManyToAny
					if( memberAttrib is MetaValueAttribute )
						WriteMetaValue(writer, member, memberAttrib as MetaValueAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaValueAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ManyToAnyAttribute )
						break; // Following attributes are for this ManyToAny
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a ManyToMany XML Element from attributes in a member. </summary>
		public virtual void WriteManyToMany(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ManyToManyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "many-to-many" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_ManyToMany_Class_DefaultValue(member) : attribute.Class);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <foreign-key>
			if(attribute.ForeignKey != null)
			writer.WriteAttributeString("foreign-key", attribute.ForeignKey);
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the ManyToManyAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is ManyToManyAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ManyToManyAttribute )
						break; // Following attributes are for this ManyToMany
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ManyToManyAttribute )
						break; // Following attributes are for this ManyToMany
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a ManyToOne XML Element from attributes in a member. </summary>
		public virtual void WriteManyToOne(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ManyToOneAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "many-to-one" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_ManyToOne_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <class>
			if(attribute.Class != null)
			writer.WriteAttributeString("class", attribute.Class);
			// Attribute: <column>
			if(attribute.Column != null)
			writer.WriteAttributeString("column", attribute.Column);
			// Attribute: <not-null>
			if( attribute.NotNullSpecified )
			writer.WriteAttributeString("not-null", attribute.NotNull ? "true" : "false");
			// Attribute: <unique>
			if( attribute.UniqueSpecified )
			writer.WriteAttributeString("unique", attribute.Unique ? "true" : "false");
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <update>
			if( attribute.UpdateSpecified )
			writer.WriteAttributeString("update", attribute.Update ? "true" : "false");
			// Attribute: <insert>
			if( attribute.InsertSpecified )
			writer.WriteAttributeString("insert", attribute.Insert ? "true" : "false");
			// Attribute: <foreign-key>
			if(attribute.ForeignKey != null)
			writer.WriteAttributeString("foreign-key", attribute.ForeignKey);
			// Attribute: <property-ref>
			if(attribute.PropertyRef != null)
			writer.WriteAttributeString("property-ref", attribute.PropertyRef);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the ManyToOneAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is ManyToOneAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ManyToOneAttribute )
						break; // Following attributes are for this ManyToOne
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <column>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ColumnAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ManyToOneAttribute )
						break; // Following attributes are for this ManyToOne
					if( memberAttrib is ColumnAttribute )
						WriteColumn(writer, member, memberAttrib as ColumnAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ColumnAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Meta XML Element from attributes in a member. </summary>
		public virtual void WriteMeta(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, MetaAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "meta" );
			// Attribute: <attribute>
			writer.WriteAttributeString("attribute", attribute.Attribute==null ? DefaultHelper.Get_Meta_Attribute_DefaultValue(member) : attribute.Attribute);
			// Attribute: <inherit>
			if( attribute.InheritSpecified )
			writer.WriteAttributeString("inherit", attribute.Inherit ? "true" : "false");
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			// Write the content of this element (mixed="true")
			writer.WriteString(attribute.Content);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a NestedCompositeElement XML Element from attributes in a member. </summary>
		public virtual void WriteNestedCompositeElement(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, NestedCompositeElementAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "nested-composite-element" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_NestedCompositeElement_Class_DefaultValue(member) : attribute.Class);
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_NestedCompositeElement_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the NestedCompositeElementAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is NestedCompositeElementAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <parent>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ParentAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is NestedCompositeElementAttribute )
						break; // Following attributes are for this NestedCompositeElement
					if( memberAttrib is ParentAttribute )
						WriteParent(writer, member, memberAttrib as ParentAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ParentAttribute), attribute);
			// Element: <property>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(PropertyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is NestedCompositeElementAttribute )
						break; // Following attributes are for this NestedCompositeElement
					if( memberAttrib is PropertyAttribute )
						WriteProperty(writer, member, memberAttrib as PropertyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(PropertyAttribute), attribute);
			// Element: <many-to-one>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToOneAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is NestedCompositeElementAttribute )
						break; // Following attributes are for this NestedCompositeElement
					if( memberAttrib is ManyToOneAttribute )
						WriteManyToOne(writer, member, memberAttrib as ManyToOneAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToOneAttribute), attribute);
			// Element: <nested-composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(NestedCompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is NestedCompositeElementAttribute )
						WriteNestedCompositeElement(writer, member, memberAttrib as NestedCompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(NestedCompositeElementAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a OneToMany XML Element from attributes in a member. </summary>
		public virtual void WriteOneToMany(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, OneToManyAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "one-to-many" );
			// Attribute: <class>
			writer.WriteAttributeString("class", attribute.Class==null ? DefaultHelper.Get_OneToMany_Class_DefaultValue(member) : attribute.Class);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a OneToOne XML Element from attributes in a member. </summary>
		public virtual void WriteOneToOne(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, OneToOneAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "one-to-one" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_OneToOne_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <class>
			if(attribute.Class != null)
			writer.WriteAttributeString("class", attribute.Class);
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <constrained>
			if( attribute.ConstrainedSpecified )
			writer.WriteAttributeString("constrained", attribute.Constrained ? "true" : "false");
			// Attribute: <foreign-key>
			if(attribute.ForeignKey != null)
			writer.WriteAttributeString("foreign-key", attribute.ForeignKey);
			// Attribute: <property-ref>
			if(attribute.PropertyRef != null)
			writer.WriteAttributeString("property-ref", attribute.PropertyRef);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the OneToOneAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is OneToOneAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is OneToOneAttribute )
						break; // Following attributes are for this OneToOne
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Param XML Element from attributes in a member. </summary>
		public virtual void WriteParam(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ParamAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "param" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Param_Name_DefaultValue(member) : attribute.Name);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			// Write the content of this element (mixed="true")
			writer.WriteString(attribute.Content);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Parent XML Element from attributes in a member. </summary>
		public virtual void WriteParent(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ParentAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "parent" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Parent_Name_DefaultValue(member) : attribute.Name);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a PrimitiveArray XML Element from attributes in a member. </summary>
		public virtual void WritePrimitiveArray(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, PrimitiveArrayAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "primitive-array" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_PrimitiveArray_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the PrimitiveArrayAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is PrimitiveArrayAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PrimitiveArrayAttribute )
						break; // Following attributes are for this PrimitiveArray
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PrimitiveArrayAttribute )
						break; // Following attributes are for this PrimitiveArray
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PrimitiveArrayAttribute )
						break; // Following attributes are for this PrimitiveArray
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PrimitiveArrayAttribute )
						break; // Following attributes are for this PrimitiveArray
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <index>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(IndexAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PrimitiveArrayAttribute )
						break; // Following attributes are for this PrimitiveArray
					if( memberAttrib is IndexAttribute )
						WriteIndex(writer, member, memberAttrib as IndexAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(IndexAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is PrimitiveArrayAttribute )
						break; // Following attributes are for this PrimitiveArray
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a List XML Element from attributes in a member. </summary>
		public virtual void WriteList(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, ListAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "list" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_List_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			// Attribute: <inverse>
			if( attribute.InverseSpecified )
			writer.WriteAttributeString("inverse", attribute.Inverse ? "true" : "false");
			// Attribute: <persister>
			if(attribute.Persister != null)
			writer.WriteAttributeString("persister", attribute.Persister);
			// Attribute: <batch-size>
			if(attribute.BatchSize != -1)
			writer.WriteAttributeString("batch-size", attribute.BatchSize.ToString());
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			// Attribute: <collection-type>
			if(attribute.CollectionType != null)
			writer.WriteAttributeString("collection-type", attribute.CollectionType);
			// Attribute: <generic>
			if( attribute.GenericSpecified )
			writer.WriteAttributeString("generic", attribute.Generic ? "true" : "false");
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the ListAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is ListAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <index>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(IndexAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is IndexAttribute )
						WriteIndex(writer, member, memberAttrib as IndexAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(IndexAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			// Element: <one-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(OneToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is OneToManyAttribute )
						WriteOneToMany(writer, member, memberAttrib as OneToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(OneToManyAttribute), attribute);
			// Element: <many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is ManyToManyAttribute )
						WriteManyToMany(writer, member, memberAttrib as ManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToManyAttribute), attribute);
			// Element: <composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is CompositeElementAttribute )
						WriteCompositeElement(writer, member, memberAttrib as CompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeElementAttribute), attribute);
			// Element: <many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is ListAttribute )
						break; // Following attributes are for this List
					if( memberAttrib is ManyToAnyAttribute )
						WriteManyToAny(writer, member, memberAttrib as ManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToAnyAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Bag XML Element from attributes in a member. </summary>
		public virtual void WriteBag(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, BagAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "bag" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Bag_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			// Attribute: <inverse>
			if( attribute.InverseSpecified )
			writer.WriteAttributeString("inverse", attribute.Inverse ? "true" : "false");
			// Attribute: <persister>
			if(attribute.Persister != null)
			writer.WriteAttributeString("persister", attribute.Persister);
			// Attribute: <batch-size>
			if(attribute.BatchSize != -1)
			writer.WriteAttributeString("batch-size", attribute.BatchSize.ToString());
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			// Attribute: <collection-type>
			if(attribute.CollectionType != null)
			writer.WriteAttributeString("collection-type", attribute.CollectionType);
			// Attribute: <generic>
			if( attribute.GenericSpecified )
			writer.WriteAttributeString("generic", attribute.Generic ? "true" : "false");
			// Attribute: <order-by>
			if(attribute.OrderBy != null)
			writer.WriteAttributeString("order-by", attribute.OrderBy);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the BagAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is BagAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			// Element: <one-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(OneToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is OneToManyAttribute )
						WriteOneToMany(writer, member, memberAttrib as OneToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(OneToManyAttribute), attribute);
			// Element: <many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is ManyToManyAttribute )
						WriteManyToMany(writer, member, memberAttrib as ManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToManyAttribute), attribute);
			// Element: <composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is CompositeElementAttribute )
						WriteCompositeElement(writer, member, memberAttrib as CompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeElementAttribute), attribute);
			// Element: <many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is BagAttribute )
						break; // Following attributes are for this Bag
					if( memberAttrib is ManyToAnyAttribute )
						WriteManyToAny(writer, member, memberAttrib as ManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToAnyAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Set XML Element from attributes in a member. </summary>
		public virtual void WriteSet(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, SetAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "set" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Set_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			// Attribute: <inverse>
			if( attribute.InverseSpecified )
			writer.WriteAttributeString("inverse", attribute.Inverse ? "true" : "false");
			// Attribute: <persister>
			if(attribute.Persister != null)
			writer.WriteAttributeString("persister", attribute.Persister);
			// Attribute: <batch-size>
			if(attribute.BatchSize != -1)
			writer.WriteAttributeString("batch-size", attribute.BatchSize.ToString());
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			// Attribute: <collection-type>
			if(attribute.CollectionType != null)
			writer.WriteAttributeString("collection-type", attribute.CollectionType);
			// Attribute: <generic>
			if( attribute.GenericSpecified )
			writer.WriteAttributeString("generic", attribute.Generic ? "true" : "false");
			// Attribute: <order-by>
			if(attribute.OrderBy != null)
			writer.WriteAttributeString("order-by", attribute.OrderBy);
			// Attribute: <sort>
			if(attribute.Sort != null)
			writer.WriteAttributeString("sort", attribute.Sort);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the SetAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is SetAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			// Element: <one-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(OneToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is OneToManyAttribute )
						WriteOneToMany(writer, member, memberAttrib as OneToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(OneToManyAttribute), attribute);
			// Element: <many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is ManyToManyAttribute )
						WriteManyToMany(writer, member, memberAttrib as ManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToManyAttribute), attribute);
			// Element: <composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is CompositeElementAttribute )
						WriteCompositeElement(writer, member, memberAttrib as CompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeElementAttribute), attribute);
			// Element: <many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is SetAttribute )
						break; // Following attributes are for this Set
					if( memberAttrib is ManyToAnyAttribute )
						WriteManyToAny(writer, member, memberAttrib as ManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToAnyAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Map XML Element from attributes in a member. </summary>
		public virtual void WriteMap(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, MapAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "map" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Map_Name_DefaultValue(member) : attribute.Name);
			// Attribute: <access>
			if(attribute.Access != null)
			writer.WriteAttributeString("access", attribute.Access);
			// Attribute: <table>
			if(attribute.Table != null)
			writer.WriteAttributeString("table", attribute.Table);
			// Attribute: <schema>
			if(attribute.Schema != null)
			writer.WriteAttributeString("schema", attribute.Schema);
			// Attribute: <lazy>
			if( attribute.LazySpecified )
			writer.WriteAttributeString("lazy", attribute.Lazy ? "true" : "false");
			// Attribute: <outer-join>
			if(attribute.OuterJoin != OuterJoinStrategy.Unspecified)
			writer.WriteAttributeString("outer-join", GetXmlEnumValue(typeof(OuterJoinStrategy), attribute.OuterJoin));
			// Attribute: <fetch>
			if(attribute.Fetch != FetchMode.Unspecified)
			writer.WriteAttributeString("fetch", GetXmlEnumValue(typeof(FetchMode), attribute.Fetch));
			// Attribute: <cascade>
			if(attribute.Cascade != CascadeStyle.Unspecified)
			writer.WriteAttributeString("cascade", GetXmlEnumValue(typeof(CascadeStyle), attribute.Cascade));
			// Attribute: <where>
			if(attribute.Where != null)
			writer.WriteAttributeString("where", attribute.Where);
			// Attribute: <inverse>
			if( attribute.InverseSpecified )
			writer.WriteAttributeString("inverse", attribute.Inverse ? "true" : "false");
			// Attribute: <persister>
			if(attribute.Persister != null)
			writer.WriteAttributeString("persister", attribute.Persister);
			// Attribute: <batch-size>
			if(attribute.BatchSize != -1)
			writer.WriteAttributeString("batch-size", attribute.BatchSize.ToString());
			// Attribute: <check>
			if(attribute.Check != null)
			writer.WriteAttributeString("check", attribute.Check);
			// Attribute: <collection-type>
			if(attribute.CollectionType != null)
			writer.WriteAttributeString("collection-type", attribute.CollectionType);
			// Attribute: <generic>
			if( attribute.GenericSpecified )
			writer.WriteAttributeString("generic", attribute.Generic ? "true" : "false");
			// Attribute: <order-by>
			if(attribute.OrderBy != null)
			writer.WriteAttributeString("order-by", attribute.OrderBy);
			// Attribute: <sort>
			if(attribute.Sort != null)
			writer.WriteAttributeString("sort", attribute.Sort);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the MapAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is MapAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <meta>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(MetaAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is MetaAttribute )
						WriteMeta(writer, member, memberAttrib as MetaAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(MetaAttribute), attribute);
			// Element: <jcs-cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(JcsCacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is JcsCacheAttribute )
						WriteJcsCache(writer, member, memberAttrib as JcsCacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(JcsCacheAttribute), attribute);
			// Element: <cache>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CacheAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is CacheAttribute )
						WriteCache(writer, member, memberAttrib as CacheAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CacheAttribute), attribute);
			// Element: <key>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(KeyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is KeyAttribute )
						WriteKey(writer, member, memberAttrib as KeyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(KeyAttribute), attribute);
			// Element: <index>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(IndexAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is IndexAttribute )
						WriteIndex(writer, member, memberAttrib as IndexAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(IndexAttribute), attribute);
			// Element: <composite-index>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeIndexAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is CompositeIndexAttribute )
						WriteCompositeIndex(writer, member, memberAttrib as CompositeIndexAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeIndexAttribute), attribute);
			// Element: <index-many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(IndexManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is IndexManyToManyAttribute )
						WriteIndexManyToMany(writer, member, memberAttrib as IndexManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(IndexManyToManyAttribute), attribute);
			// Element: <index-many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(IndexManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is IndexManyToAnyAttribute )
						WriteIndexManyToAny(writer, member, memberAttrib as IndexManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(IndexManyToAnyAttribute), attribute);
			// Element: <element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is ElementAttribute )
						WriteElement(writer, member, memberAttrib as ElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ElementAttribute), attribute);
			// Element: <one-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(OneToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is OneToManyAttribute )
						WriteOneToMany(writer, member, memberAttrib as OneToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(OneToManyAttribute), attribute);
			// Element: <many-to-many>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToManyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is ManyToManyAttribute )
						WriteManyToMany(writer, member, memberAttrib as ManyToManyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToManyAttribute), attribute);
			// Element: <composite-element>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(CompositeElementAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is CompositeElementAttribute )
						WriteCompositeElement(writer, member, memberAttrib as CompositeElementAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(CompositeElementAttribute), attribute);
			// Element: <many-to-any>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ManyToAnyAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is MapAttribute )
						break; // Following attributes are for this Map
					if( memberAttrib is ManyToAnyAttribute )
						WriteManyToAny(writer, member, memberAttrib as ManyToAnyAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ManyToAnyAttribute), attribute);
			
			writer.WriteEndElement();
		}
		
		/// <summary> Write a Type XML Element from attributes in a member. </summary>
		public virtual void WriteType(System.Xml.XmlWriter writer, System.Reflection.MemberInfo member, TypeAttribute attribute, BaseAttribute parentAttribute)
		{
			writer.WriteStartElement( "type" );
			// Attribute: <name>
			writer.WriteAttributeString("name", attribute.Name==null ? DefaultHelper.Get_Type_Name_DefaultValue(member) : attribute.Name);
			
			WriteUserDefinedContent(writer, member, null, attribute);
			
			System.Collections.ArrayList memberAttribs = GetSortedAttributes(member);
			int attribPos; // Find the position of the TypeAttribute (its <sub-element>s must be after it)
			for(attribPos=0; attribPos<memberAttribs.Count; attribPos++)
				if( memberAttribs[attribPos] is TypeAttribute
					&& ((BaseAttribute)memberAttribs[attribPos]).Position == attribute.Position )
					break; // found
			int i = attribPos + 1;

			// Element: <param>
			for(; i<memberAttribs.Count; i++)
			{
				BaseAttribute memberAttrib = memberAttribs[i] as BaseAttribute;
				if( IsNextElement(memberAttrib, parentAttribute, attribute.GetType())
					|| IsNextElement(memberAttrib, attribute, typeof(ParamAttribute)) )
					break; // next attributes are 'elements' of the same level OR for 'sub-elements'
				else
				{
					if( memberAttrib is TypeAttribute )
						break; // Following attributes are for this Type
					if( memberAttrib is ParamAttribute )
						WriteParam(writer, member, memberAttrib as ParamAttribute, attribute);
				}
			}
			WriteUserDefinedContent(writer, member, typeof(ParamAttribute), attribute);
			
			writer.WriteEndElement();
		}
	}
}
