using System;
using System.Collections;
using System.Data;
using System.Reflection;

using Iesi.Collections;

using log4net;

using NHibernate.Cache;
using NHibernate.Engine;
using NHibernate.Exceptions;
using NHibernate.Hql;
using NHibernate.Id;
using NHibernate.Impl;
using NHibernate.Loader;
using NHibernate.Mapping;
using NHibernate.Metadata;
using NHibernate.Property;
using NHibernate.Proxy;
using NHibernate.SqlCommand;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Persister
{
	/// <summary>
	/// Superclass for built-in mapping strategies. Implements functionalty common to both mapping
	/// strategies
	/// </summary>
	/// <remarks>
	/// May be considred an immutable view of the mapping object
	/// </remarks>
	public abstract class AbstractEntityPersister : AbstractPropertyMapping, IOuterJoinLoadable, IQueryable, IClassMetadata, IUniqueKeyLoadable, ISqlLoadable
	{
		private static readonly ILog log = LogManager.GetLogger( typeof( AbstractEntityPersister ) );

		public const string EntityClass = "class";

		private readonly Dialect.Dialect dialect;
		//private readonly SQLExceptionConverter sqlExceptionConverter;

		// The class itself
		private readonly System.Type mappedClass;
		private readonly bool polymorphic;
		private readonly bool explicitPolymorphism;
		private readonly bool inherited;
		private readonly bool hasSubclasses;
		private readonly bool versioned;
		private readonly bool abstractClass;
		private readonly bool implementsLifecycle;
		private readonly bool implementsValidatable;
		private readonly bool hasCollections;
		private readonly bool hasCascades;
		private readonly bool mutable;
		private readonly bool selectBeforeUpdate;
		private readonly System.Type superclass;
		private readonly bool dynamicUpdate;
		private readonly bool dynamicInsert;
		private readonly OptimisticLockMode optimisticLockMode;
		private readonly string className;
		private readonly int batchSize;
		private readonly IType entityType;
		private readonly ConstructorInfo constructor;
		//Not ported:
		//private final BulkBean optimizer;
		//private final FastClass fastClass;
		private readonly string rootClassName;

		// The optional SQL string defined in the where attribute
		private readonly string sqlWhereString;
		private readonly string sqlWhereStringTemplate;

		// proxies (if the proxies are interfaces, we use an array of interfaces of all subclasses)
		private readonly System.Type concreteProxyClass;
		private readonly bool hasProxy;
		private readonly IProxyFactory proxyFactory;

		// The SQL string used to retrieve a primary key generated by SQL INSERT
		private readonly bool useIdentityColumn;
		private readonly string identitySelectString;

		// the identifier property
		private readonly bool hasEmbeddedIdentifier;
		private readonly string identifierPropertyName;
		private readonly string[ ] identifierColumnNames;
		private readonly string[ ] identifierAliases;
		private readonly Cascades.IdentifierValue unsavedIdentifierValue;
		private readonly IType identifierType;
		private readonly ISetter identifierSetter;
		private readonly IGetter identifierGetter;
		private readonly IIdentifierGenerator identifierGenerator;

		// version property
		private readonly string versionColumnName;
		private readonly IVersionType versionType;
		private readonly IGetter versionGetter;
		private readonly int versionProperty;
		private Cascades.VersionValue unsavedVersionValue;
		//private readonly bool batchVersionData;

		// other properties (for this concrete class only, not the subclass closure)
		private readonly int hydrateSpan;
		private readonly string[ ] propertyNames;
		private readonly IType[ ] propertyTypes;
		private readonly bool[ ] propertyUpdateability;
		private readonly bool[ ] propertyInsertability;
		private readonly bool[ ] propertyNullability;
		private readonly IGetter[ ] getters;
		private readonly ISetter[ ] setters;
		private readonly Cascades.CascadeStyle[ ] cascadeStyles;

		private readonly Hashtable gettersByPropertyName = new Hashtable();
		private readonly Hashtable settersByPropertyName = new Hashtable();
		private readonly Hashtable typesByPropertyName = new Hashtable();

		// the cache
		private readonly ICacheConcurrencyStrategy cache;

		private readonly Hashtable uniqueKeyLoaders = new Hashtable();
		private readonly Hashtable uniqueKeyColumns = new Hashtable();

		private readonly Hashtable subclassPropertyAliases = new Hashtable();

		private readonly Hashtable lockers = new Hashtable();

		protected SqlString GetLockString( LockMode lockMode )
		{
			return ( SqlString ) lockers[ lockMode ];
		}

		public System.Type MappedClass
		{
			get { return mappedClass; }
		}

		public override string ClassName
		{
			get { return className; }
		}

		public virtual object IdentifierSpace
		{
			get { return rootClassName; }
		}

		public virtual SqlString IdentifierSelectFragment( string name, string suffix )
		{
			return new SelectFragment( Dialect )
				.SetSuffix( suffix )
				.AddColumns( name, IdentifierColumnNames, IdentifierAliases )
				.ToSqlStringFragment( false );
		}

		public virtual Cascades.CascadeStyle[ ] PropertyCascadeStyles
		{
			get { return cascadeStyles; }
		}

		/// <summary>
		/// Set the given values to the mapped properties of the given object
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="values"></param>
		public virtual void SetPropertyValues( object obj, object[ ] values )
		{
			//TODO: optimizer implementation
			for( int j = 0; j < HydrateSpan; j++ )
			{
				Setters[ j ].Set( obj, values[ j ] );
			}
		}

		/// <summary>
		/// Return the values of the mapped properties of the object
		/// </summary>
		/// <param name="obj"></param>
		/// <returns></returns>
		public virtual object[ ] GetPropertyValues( object obj )
		{
			int span = HydrateSpan;
			//TODO: optimizer implementation
			object[ ] result = new object[span];
			for( int j = 0; j < span; j++ )
			{
				result[ j ] = Getters[ j ].Get( obj );
			}
			return result;
		}

		/// <summary>
		/// Get the value of the numbered property
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="i"></param>
		/// <returns></returns>
		public virtual object GetPropertyValue( object obj, int i )
		{
			return Getters[ i ].Get( obj );
		}

		/// <summary>
		/// Set the value of the numbered property
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="i"></param>
		/// <param name="value"></param>
		public virtual void SetPropertyValue( object obj, int i, object value )
		{
			Setters[ i ].Set( obj, value );
		}

		/// <summary>
		/// Determine if the given field values are dirty.
		/// </summary>
		/// <param name="x"></param>
		/// <param name="y"></param>
		/// <param name="obj"></param>
		/// <param name="session"></param>
		/// <returns></returns>
		public virtual int[ ] FindDirty( object[ ] x, object[ ] y, object obj, ISessionImplementor session )
		{
			int[ ] props = TypeFactory.FindDirty( propertyTypes, x, y, propertyUpdateability, session );
			if( props == null )
			{
				return null;
			}
			else
			{
				if( log.IsDebugEnabled )
				{
					for( int i = 0; i < props.Length; i++ )
					{
						log.Debug( StringHelper.Qualify( className, propertyNames[ props[ i ] ] ) + " is dirty" );
					}
				}
				return props;
			}
		}

		/// <summary>
		/// Determine if the given field values are dirty.
		/// </summary>
		/// <param name="old"></param>
		/// <param name="current"></param>
		/// <param name="obj"></param>
		/// <param name="session"></param>
		/// <returns></returns>
		public virtual int[ ] FindModified( object[ ] old, object[ ] current, object obj, ISessionImplementor session )
		{
			int[ ] props = TypeFactory.FindModified( propertyTypes, old, current, propertyUpdateability, session );
			if( props == null )
			{
				return null;
			}
			else
			{
				if( log.IsDebugEnabled )
				{
					for( int i = 0; i < props.Length; i++ )
					{
						log.Debug( StringHelper.Qualify( className, propertyNames[ props[ i ] ] ) + " is dirty" );
					}
				}
				return props;
			}
		}

		public virtual object GetIdentifier( object obj )
		{
			object id;
			if( HasEmbeddedIdentifier )
			{
				id = obj;
			}
			else
			{
				if( identifierGetter == null )
				{
					throw new HibernateException( "The class has no identifier property: " + className );
				}
				id = identifierGetter.Get( obj );
			}
			return id;
		}

		public virtual object GetVersion( object obj )
		{
			if( !versioned )
			{
				return null;
			}
			return versionGetter.Get( obj );
		}

		public virtual void SetIdentifier( object obj, object id )
		{
			if( HasEmbeddedIdentifier )
			{
				ComponentType copier = ( ComponentType ) identifierType;
				copier.SetPropertyValues( obj, copier.GetPropertyValues( id ) );
			}
			else if( identifierSetter != null )
			{
				identifierSetter.Set( obj, id );
			}
		}

		/// <summary>
		/// Return a new instance initialized with the given identifier.
		/// </summary>
		/// <param name="id"></param>
		/// <returns></returns>
		public virtual object Instantiate( object id )
		{
			if( HasEmbeddedIdentifier && id.GetType() == mappedClass )
			{
				return id;
			}
			else
			{
				if( abstractClass )
				{
					throw new HibernateException( "Cannot instantiate abstract class or interface: " + className );
				}

				object result;
				//TODO: optimizer implementation
				try
				{
					result = constructor.Invoke( null );
				}
				catch( Exception e )
				{
					throw new InstantiationException( "Could not instantiate entity: ", e, mappedClass );
				}

				SetIdentifier( result, id );
				return result;
			}
		}

		protected virtual ISetter[ ] Setters
		{
			get { return setters; }
		}

		protected virtual IGetter[ ] Getters
		{
			get { return getters; }
		}

		public virtual IType[ ] PropertyTypes
		{
			get { return propertyTypes; }
		}

		public virtual IType IdentifierType
		{
			get { return identifierType; }
		}

		public override string[ ] IdentifierColumnNames
		{
			get { return identifierColumnNames; }
		}

		public string[ ] IdentifierAliases
		{
			get { return identifierAliases; }
		}

		public virtual bool IsPolymorphic
		{
			get { return polymorphic; }
		}

		public virtual bool IsInherited
		{
			get { return inherited; }
		}

		public virtual bool HasCascades
		{
			get { return hasCascades; }
		}

		public virtual ICacheConcurrencyStrategy Cache
		{
			get { return cache; }
		}

		public virtual bool HasIdentifierProperty
		{
			get { return identifierGetter != null; }
		}

		public virtual IVersionType VersionType
		{
			get { return versionType; }
		}

		public virtual int VersionProperty
		{
			get { return versionProperty; }
		}

		public virtual bool IsVersioned
		{
			get { return versioned; }
		}

		public bool IsBatchable
		{
			get { return /* jdbcBatchVersionedData || */ !IsVersioned; }
		}

		public virtual bool IsIdentifierAssignedByInsert
		{
			get { return useIdentityColumn; }
		}

		public bool IsUnsaved( object obj )
		{
			object id;
			if( HasIdentifierPropertyOrEmbeddedCompositeIdentifier )
			{
				id = GetIdentifier( obj );
			}
			else
			{
				id = null;
			}
			// we always assume a transient instance with a null
			// identifier or no identifier property is unsaved!
			if( id == null )
			{
				return true;
			}

			if( IsVersioned )
			{
				// let this take precedence if defined, since it works for
				// assigned identifiers
				object result = unsavedVersionValue.IsUnsaved( GetVersion( obj ) );
				if( result != null )
				{
					return ( bool ) result;
				}
			}
			return unsavedIdentifierValue.IsUnsaved( id );
		}

		/// <summary></summary>
		public virtual string[ ] PropertyNames
		{
			get { return propertyNames; }
		}

		/// <summary></summary>
		public virtual string IdentifierPropertyName
		{
			get { return identifierPropertyName; }
		}

		/// <summary></summary>
		public virtual string VersionColumnName
		{
			get { return versionColumnName; }
		}

		/// <summary></summary>
		public virtual bool ImplementsLifecycle
		{
			get { return implementsLifecycle; }
		}

		/// <summary></summary>
		public virtual bool ImplementsValidatable
		{
			get { return implementsValidatable; }
		}

		/// <summary></summary>
		public virtual bool HasCollections
		{
			get { return hasCollections; }
		}

		/// <summary></summary>
		public virtual bool IsMutable
		{
			get { return mutable; }
		}

		/// <summary></summary>
		public virtual bool HasCache
		{
			get { return cache != null; }
		}

		/// <summary></summary>
		public virtual bool HasSubclasses
		{
			get { return hasSubclasses; }
		}

		/// <summary></summary>
		public virtual bool HasProxy
		{
			get { return hasProxy; }
		}

		/// <summary>
		/// Returns the SQL used to get the Identity value from the last insert.
		/// </summary>
		/// <remarks>This is not a NHibernate Command because there are no parameters.</remarks>
		public string SqlIdentitySelect
		{
			get { return identitySelectString; }
		}

		public virtual IIdentifierGenerator IdentifierGenerator
		{
			get
			{
				if( identifierGenerator == null )
				{
					throw new HibernateException( "No ID generator is configured for class " + className + " (Try using Save() with an assigned ID)" );
				}
				return identifierGenerator;
			}
		}

		/// <summary>
		/// Checks to make sure that one and only one row was affected
		/// by the IDbCommand that was run.
		/// </summary>
		/// <param name="rows">The results of IDbCommand..ExecuteNonQuery()</param>
		/// <param name="id">The idenitifer of the Entity.  Use for logging purposes.</param>
		protected virtual void Check( int rows, object id )
		{
			if( rows < 1 )
			{
				throw new StaleObjectStateException( MappedClass, id );
			}
			else if( rows > 1 )
			{
				throw new HibernateException( "Duplicate identifier in table for " + ClassName + ": " + id );
			}
		}

		protected abstract string[ ] GetActualPropertyColumnNames( int i );
		protected abstract string GetFormulaTemplate( int i );

		protected void InitPropertyPaths( ISessionFactoryImplementor factory )
		{
			IType[ ] propertyTypes = PropertyTypes;
			string[ ] propertyNames = PropertyNames;

			for( int i = 0; i < propertyNames.Length; i++ )
			{
				InitPropertyPaths( propertyNames[ i ], propertyTypes[ i ], GetActualPropertyColumnNames( i ), GetFormulaTemplate( i ), factory );
			}

			string idProp = IdentifierPropertyName;
			if( idProp != null )
			{
				InitPropertyPaths( idProp, IdentifierType, IdentifierColumnNames, factory );
			}
			if( HasEmbeddedIdentifier )
			{
				InitPropertyPaths( null, IdentifierType, IdentifierColumnNames, factory );
			}
			InitPropertyPaths( PathExpressionParser.EntityID, IdentifierType, IdentifierColumnNames, factory );

			if( IsPolymorphic )
			{
				AddPropertyPath( PathExpressionParser.EntityClass, DiscriminatorType, new string[ ] {DiscriminatorColumnName} );
			}
		}

		protected AbstractEntityPersister( PersistentClass model, ISessionFactoryImplementor factory )
		{
			dialect = factory.Dialect;
			//sqlExceptionConverter = factory.SQLExceptionConverter;

			// CLASS
			className = model.MappedClass.FullName;
			rootClassName = model.RootClazz.Name;
			mappedClass = model.MappedClass;

			mutable = model.IsMutable;
			selectBeforeUpdate = model.SelectBeforeUpdate;
			dynamicUpdate = model.DynamicUpdate;
			dynamicInsert = model.DynamicInsert;
			sqlWhereString = model.Where;
			sqlWhereStringTemplate = sqlWhereString == null ?
				null :
				Template.RenderWhereStringTemplate( sqlWhereString, Dialect );

			polymorphic = model.IsPolymorphic;
			explicitPolymorphism = model.IsExplicitPolymorphism;
			inherited = model.IsInherited;
			superclass = inherited ? model.Superclass.MappedClass : null;
			hasSubclasses = model.HasSubclasses;

			batchSize = model.BatchSize;

			constructor = ReflectHelper.GetDefaultConstructor( mappedClass );
			abstractClass = ReflectHelper.IsAbstractClass( mappedClass );

			entityType = NHibernateUtil.Entity( mappedClass );

			optimisticLockMode = model.OptimisticLockMode;
			if( optimisticLockMode > OptimisticLockMode.Version && !dynamicUpdate )
			{
				throw new MappingException( string.Format( "optimistic-lock setting requires dynamic-update=\'true\': {0}", className ) );
			}

			// verify that the class has a default constructor if it is not abstract - it is considered
			// a mapping exception if the default ctor is missing.
			if( abstractClass == false && constructor == null )
			{
				throw new MappingException( "The mapped class " + mappedClass.FullName + " must declare a default (no-arg) constructor." );
			}

			// IDENTIFIER
			hasEmbeddedIdentifier = model.HasEmbeddedIdentifier;
			IValue idValue = model.Identifier;
			identifierType = idValue.Type;

			if( model.HasIdentifierProperty )
			{
				Mapping.Property idProperty = model.IdentifierProperty;
				identifierPropertyName = idProperty.Name;
				identifierSetter = idProperty.GetSetter( mappedClass );
				identifierGetter = idProperty.GetGetter( mappedClass );
			}
			else
			{
				identifierPropertyName = null;
				identifierGetter = null;
				identifierSetter = null;
			}

			System.Type prox = model.ProxyInterface;
			MethodInfo proxySetIdentifierMethod = null;
			MethodInfo proxyGetIdentifierMethod = null;

			if( model.HasIdentifierProperty && prox != null )
			{
				Mapping.Property idProperty = model.IdentifierProperty;

				PropertyInfo getIdPropertyInfo = idProperty.GetGetter( prox ).Property;

				if( getIdPropertyInfo != null )
				{
					proxyGetIdentifierMethod = getIdPropertyInfo.GetGetMethod( true );
				}

				PropertyInfo setIdPropertyInfo = idProperty.GetSetter( prox ).Property;

				if( setIdPropertyInfo != null )
				{
					proxySetIdentifierMethod = setIdPropertyInfo.GetSetMethod( true );
				}
			}

			// HYDRATE SPAN
			hydrateSpan = model.PropertyClosureCollection.Count;

			// IDENTIFIER 
			int idColumnSpan = model.Identifier.ColumnSpan;
			identifierColumnNames = new string[idColumnSpan];
			identifierAliases = new string[idColumnSpan];

			int i = 0;
			foreach( Column col in idValue.ColumnCollection )
			{
				identifierColumnNames[ i ] = col.GetQuotedName( Dialect );
				identifierAliases[ i ] = col.Alias( Dialect );
				i++;
			}

			// GENERATOR
			identifierGenerator = model.Identifier.CreateIdentifierGenerator( Dialect );
			useIdentityColumn = identifierGenerator is IdentityGenerator;
			identitySelectString = useIdentityColumn ? dialect.IdentitySelectString : null;

			// UNSAVED-VALUE:
			string unsavedValue = model.Identifier.NullValue;
			if( unsavedValue == null || "null".Equals( unsavedValue ) )
			{
				unsavedIdentifierValue = Cascades.IdentifierValue.SaveNull;
			}
			else if( "none".Equals( unsavedValue ) )
			{
				unsavedIdentifierValue = Cascades.IdentifierValue.SaveNone;
			}
			else if( "any".Equals( unsavedValue ) )
			{
				unsavedIdentifierValue = Cascades.IdentifierValue.SaveAny;
			}
			else
			{
				IType idType = model.Identifier.Type;
				try
				{
					unsavedIdentifierValue = new Cascades.IdentifierValue( ( ( IIdentifierType ) idType ).StringToObject( unsavedValue ) );
				}
				catch( InvalidCastException )
				{
					throw new MappingException( "Bad identifier type: " + idType.GetType().Name );
				}
				catch( Exception )
				{
					throw new MappingException( "Could not parse unsaved-value: " + unsavedValue );
				}
			}

			// VERSION:

			if( model.IsVersioned )
			{
				foreach( Column col in model.Version.ColumnCollection )
				{
					versionColumnName = col.GetQuotedName( Dialect );
					break; //only happens once
				}
			}
			else
			{
				versionColumnName = null;
			}

			if( model.IsVersioned )
			{
				//versionPropertyName = model.Version.Name;
				versioned = true;
				versionGetter = model.Version.GetGetter( mappedClass );
				versionType = ( IVersionType ) model.Version.Type;
			}
			else
			{
				//versionPropertyName = null;
				versioned = false;
				versionGetter = null;
				versionType = null;
			}

			// VERSION UNSAVED-VALUE:
			string versionUnsavedValue = null;
			if( model.IsVersioned )
			{
				versionUnsavedValue = model.Version.NullValue;
			}

			if( versionUnsavedValue == null || "undefined".Equals( versionUnsavedValue ) )
			{
				unsavedVersionValue = Cascades.VersionValue.VersionUndefined;
			}
			else if( "null".Equals( versionUnsavedValue ) )
			{
				unsavedVersionValue = Cascades.VersionValue.VersionSaveNull;
			}
			else if( "negative".Equals( versionUnsavedValue ) )
			{
				unsavedVersionValue = Cascades.VersionValue.VersionNegative;
				/*
				 * used to be none and any strategies but this is kind of a nonsense for version
				 * especially for none since an 'update where' would be generated
				 * Lot's of hack to support none ?
				 */
			}
			else
			{
				// NB This is NHibernate specific - needed so we can specify a default value for dates as we don't have null as a possibility
				IType idType = model.Identifier.Type;
				try
				{
					unsavedVersionValue = new Cascades.VersionValue( versionType.StringToObject( versionUnsavedValue ) );
				}
				catch( InvalidCastException )
				{
					throw new MappingException( "Bad version type: " + idType.GetType().Name );
				}
				catch( Exception )
				{
					throw new MappingException( "Could not parse version unsaved-value: " + versionUnsavedValue );
				}
			}

			// PROPERTIES 

			propertyTypes = new IType[hydrateSpan];
			propertyNames = new string[hydrateSpan];
			propertyUpdateability = new bool[hydrateSpan];
			propertyInsertability = new bool[hydrateSpan];
			propertyNullability = new bool[hydrateSpan];
			getters = new IGetter[hydrateSpan];
			setters = new ISetter[hydrateSpan];
			cascadeStyles = new Cascades.CascadeStyle[hydrateSpan];
			string[ ] setterNames = new string[hydrateSpan];
			string[ ] getterNames = new string[hydrateSpan];
			System.Type[ ] types = new System.Type[hydrateSpan];

			i = 0;
			int tempVersionProperty = -66;
			bool foundCascade = false;
			//bool foundCustomAccessor = false;

			foreach( Mapping.Property prop in model.PropertyClosureCollection )
			{
				if( prop == model.Version )
				{
					tempVersionProperty = i;
				}
				propertyNames[ i ] = prop.Name;
				getters[ i ] = prop.GetGetter( mappedClass );
				setters[ i ] = prop.GetSetter( mappedClass );
				getterNames[ i ] = getters[ i ].PropertyName;
				setterNames[ i ] = setters[ i ].PropertyName;
				types[ i ] = getters[ i ].ReturnType;
				propertyTypes[ i ] = prop.Type;
				propertyUpdateability[ i ] = prop.IsUpdateable;
				propertyInsertability[ i ] = prop.IsInsertable;
				propertyNullability[ i ] = prop.IsNullable;

				gettersByPropertyName[ propertyNames[ i ] ] = getters[ i ];
				settersByPropertyName[ propertyNames[ i ] ] = setters[ i ];
				typesByPropertyName[ propertyNames[ i ] ] = propertyTypes[ i ];

				cascadeStyles[ i ] = prop.CascadeStyle;
				if( cascadeStyles[ i ] != Cascades.CascadeStyle.StyleNone )
				{
					foundCascade = true;
				}

				i++;
			}

			//TODO: optimizer implementation

			hasCascades = foundCascade;
			versionProperty = tempVersionProperty;

			// CALLBACK INTERFACES
			implementsLifecycle = typeof( ILifecycle ).IsAssignableFrom( mappedClass );
			implementsValidatable = typeof( IValidatable ).IsAssignableFrom( mappedClass );

			cache = model.Cache;

			hasCollections = InitHasCollections();

			// PROXIES
			concreteProxyClass = model.ProxyInterface;
			hasProxy = concreteProxyClass != null;

			if( hasProxy )
			{
				HashedSet proxyInterfaces = new HashedSet();
				proxyInterfaces.Add( typeof( INHibernateProxy ) );

				if( !mappedClass.Equals( concreteProxyClass ) )
				{
					if( !concreteProxyClass.IsInterface )
					{
						throw new MappingException(
							"proxy must be either an interface, or the class itself: " +
								mappedClass.FullName );
					}

					proxyInterfaces.Add( concreteProxyClass );
				}

				if( mappedClass.IsInterface )
				{
					proxyInterfaces.Add( mappedClass );
				}

				if( hasProxy )
				{
					foreach( Subclass subclass in model.SubclassCollection )
					{
						System.Type subclassProxy = subclass.ProxyInterface;
						if( subclassProxy == null )
						{
							throw new MappingException( "All subclasses must also have proxies: "
								+ mappedClass.Name );
						}

						if( !subclass.MappedClass.Equals( subclassProxy ) )
						{
							proxyInterfaces.Add( subclassProxy );
						}
					}
				}

				if( hasProxy )
				{
					proxyFactory = CreateProxyFactory();
					proxyFactory.PostInstantiate( mappedClass, proxyInterfaces, proxyGetIdentifierMethod, proxySetIdentifierMethod );
				}
				else
				{
					proxyFactory = null;
				}
			}
			else
			{
				proxyFactory = null;
			}
		}

		protected virtual IProxyFactory CreateProxyFactory()
		{
			return new CastleProxyFactory();
		}

		/// <summary>
		/// Must be called by subclasses, at the end of their constructors
		/// </summary>
		/// <param name="model"></param>
		protected void InitSubclassPropertyAliasesMap( PersistentClass model )
		{
			// ALIASES
			InternalInitSubclassPropertyAliasesMap( null, model.SubclassPropertyClosureCollection );

			// aliases for identifier
			if( HasIdentifierProperty )
			{
				subclassPropertyAliases[ IdentifierPropertyName ] = identifierAliases;
				subclassPropertyAliases[ PathExpressionParser.EntityID ] = identifierAliases;
			}

			if( HasEmbeddedIdentifier )
			{
				// Fetch embedded identifier property names from the "virtual" identifier component
				IAbstractComponentType componentId = ( IAbstractComponentType ) identifierType;
				string[ ] idPropertyNames = componentId.PropertyNames;
				string[ ] idAliases = IdentifierAliases;

				for( int i = 0; i < idPropertyNames.Length; i++ )
				{
					subclassPropertyAliases[ idPropertyNames[ i ] ] = new string[ ] {idAliases[ i ]};
				}
			}

			if( IsPolymorphic )
			{
				subclassPropertyAliases[ PathExpressionParser.EntityClass ] = new string[ ] {DiscriminatorAlias};
			}
		}

		private void InternalInitSubclassPropertyAliasesMap( string path, ICollection col )
		{
			foreach( Mapping.Property prop in col )
			{
				string propName = path == null ? prop.Name : path + "." + prop.Name;
				if( prop.IsComposite )
				{
					Component component = ( Component ) prop.Value;
					InternalInitSubclassPropertyAliasesMap( propName, component.PropertyCollection );
				}
				else
				{
					string[ ] aliases = new string[prop.ColumnSpan];
					string[ ] cols = new string[prop.ColumnSpan];
					int l = 0;
					foreach( Column thing in prop.ColumnCollection )
					{
						aliases[ l ] = thing.Alias( dialect );
						cols[ l ] = thing.GetQuotedName( dialect );
						l++;
					}

					// used for loading entities by a unique key
					if( prop.Value.IsUnique )
					{
						uniqueKeyColumns[ propName ] = cols;
					}

					subclassPropertyAliases[ propName ] = aliases;
				}
			}
		}

		protected void InitLockers()
		{
			SqlString lockString = GenerateLockString( null, null );
			SqlString lockExclusiveString = Dialect.SupportsForUpdate ?
				GenerateLockString( lockString, " for update" ) :
				GenerateLockString( lockString, null );
			SqlString lockExclusiveNowaitString = Dialect.SupportsForUpdateNoWait ?
				GenerateLockString( lockString, " for update nowait" ) :
				GenerateLockString( lockExclusiveString, null );

			lockers.Add( LockMode.Read, lockString );
			lockers.Add( LockMode.Upgrade, lockExclusiveString );
			lockers.Add( LockMode.UpgradeNoWait, lockExclusiveNowaitString );
		}

		protected abstract SqlString GenerateLockString( SqlString sqlString, string forUpdateFragment );

		/// <summary></summary>
		private bool InitHasCollections()
		{
			return InitHasCollections( propertyTypes );
		}

		private bool InitHasCollections( IType[ ] types )
		{
			for( int i = 0; i < types.Length; i++ )
			{
				if( types[ i ].IsPersistentCollectionType )
				{
					return true;
				}
				else if( types[ i ].IsComponentType )
				{
					if( InitHasCollections( ( ( IAbstractComponentType ) types[ i ] ).Subtypes ) )
					{
						return true;
					}
				}
			}
			return false;
		}

		public virtual IClassMetadata ClassMetadata
		{
			get { return this; }
		}

		public virtual System.Type ConcreteProxyClass
		{
			get { return concreteProxyClass; }
		}

		public virtual System.Type MappedSuperclass
		{
			get { return superclass; }
		}

		public virtual bool IsExplicitPolymorphism
		{
			get { return explicitPolymorphism; }
		}

		public virtual bool[ ] PropertyUpdateability
		{
			get { return propertyUpdateability; }
		}

		public virtual bool[ ] PropertyNullability
		{
			get { return propertyNullability; }
		}

		protected virtual bool UseDynamicUpdate
		{
			get { return dynamicUpdate; }
		}

		protected virtual bool UseDynamicInsert
		{
			get { return dynamicInsert; }
		}

		public virtual bool[ ] PropertyInsertability
		{
			get { return propertyInsertability; }
		}

		public virtual object GetPropertyValue( object obj, string propertyName )
		{
			IGetter getter = ( IGetter ) gettersByPropertyName[ propertyName ];
			if( getter == null )
			{
				throw new HibernateException( "unmapped property: " + propertyName );
			}
			return getter.Get( obj );
		}

		public virtual void SetPropertyValue( object obj, string propertyName, object value )
		{
			ISetter setter = ( ISetter ) settersByPropertyName[ propertyName ];
			if( setter == null )
			{
				throw new HibernateException( "unmapped property: " + propertyName );
			}
			setter.Set( obj, value );
		}

		protected virtual bool HasEmbeddedIdentifier
		{
			get { return hasEmbeddedIdentifier; }
		}

		public bool[ ] GetNotNullInsertableColumns( object[ ] fields )
		{
			bool[ ] notNull = new bool[fields.Length];
			bool[ ] insertable = PropertyInsertability;

			for( int i = 0; i < fields.Length; i++ )
			{
				notNull[ i ] = insertable[ i ] && fields[ i ] != null;
			}

			return notNull;
		}

		/// <summary></summary>
		protected Dialect.Dialect Dialect
		{
			get { return dialect; }
		}

		protected string GetSQLWhereString( string alias )
		{
			return StringHelper.Replace( sqlWhereStringTemplate, Template.Placeholder, alias );
		}

		protected bool HasWhere
		{
			get { return ( sqlWhereString != null && sqlWhereString.Length > 0 ); }
		}

		public virtual bool HasIdentifierPropertyOrEmbeddedCompositeIdentifier
		{
			get { return HasIdentifierProperty || HasEmbeddedIdentifier; }
		}

		protected void CheckColumnDuplication( ISet distinctColumns, ICollection columns )
		{
			foreach( Column col in columns )
			{
				if( !distinctColumns.Add( col.Name ) )
				{
					throw new MappingException(
						"Repated column in mapping for class " +
							className +
							" should be mapped with insert=\"false\" update=\"false\": " +
							col.Name );
				}
			}
		}

		protected IUniqueEntityLoader CreateEntityLoader( ISessionFactoryImplementor factory )
		{
			Loader.Loader nonBatchLoader = new EntityLoader( this, 1, factory );
			if( batchSize > 1 )
			{
				Loader.Loader batchLoader = new EntityLoader( this, batchSize, factory );
				int smallBatchSize = ( int ) Math.Round( Math.Sqrt( batchSize ) );
				Loader.Loader smallBatchLoader = new EntityLoader( this, smallBatchSize, factory );
				return new BatchingEntityLoader( this, batchSize, batchLoader, smallBatchSize, smallBatchLoader, nonBatchLoader );
			}
			else
			{
				return ( IUniqueEntityLoader ) nonBatchLoader;
			}
		}

		protected void CreateUniqueKeyLoaders( ISessionFactoryImplementor factory )
		{
			// TODO: Does not handle components, or properties of a joined subclass
			for( int i = 0; i < propertyNames.Length; i++ )
			{
				string[ ] columns = ( string[ ] ) uniqueKeyColumns[ propertyNames[ i ] ];
				if( columns != null )
				{
					IType uniqueKeyType = propertyTypes[ i ];
					if( uniqueKeyType.IsEntityType )
					{
						System.Type clazz = ( ( EntityType ) uniqueKeyType ).AssociatedClass;
						uniqueKeyType = factory.GetPersister( clazz ).IdentifierType;
					}
					uniqueKeyLoaders.Add( propertyNames[ i ], new EntityLoader( this, columns, uniqueKeyType, 1, factory ) );
				}
			}
		}

		public override IType Type
		{
			get { return entityType; }
		}

		protected int HydrateSpan
		{
			get { return hydrateSpan; }
		}

		public bool IsBatchLoadable
		{
			get { return batchSize > 1; }
		}

		public string[ ] GetSubclassPropertyColumnAliases( string propertyName, string suffix )
		{
			string[ ] rawAliases = ( string[ ] ) subclassPropertyAliases[ propertyName ];

			if( rawAliases == null )
			{
				return null;
			}

			string[ ] result = new string[rawAliases.Length];
			for( int i = 0; i < rawAliases.Length; i++ )
			{
				result[ i ] = new Alias( suffix ).ToUnquotedAliasString( rawAliases[ i ], Dialect );
			}
			return result;
		}

		public string[ ] JoinKeyColumnNames
		{
			get { return IdentifierColumnNames; }
		}

		public string Name
		{
			get { return ClassName; }
		}

		public SqlString SelectFragment( string alias, string suffix )
		{
			return IdentifierSelectFragment( alias, suffix ).Append( PropertySelectFragment( alias, suffix ) );
		}

		public string[ ] GetIdentifierAliases( string suffix )
		{
			// NOTE: this assumes something about how PropertySelectFragment is implemented by the subclass!
			// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
			// to remove that unquoting and missing aliases..
			return new Alias( suffix ).ToAliasStrings( IdentifierAliases, dialect );
		}

		public string[ ] GetPropertyAliases( string suffix, int i )
		{
			// NOTE: this assumes something about how pPropertySelectFragment is implemented by the subclass!
			return new Alias( suffix ).ToUnquotedAliasStrings( GetPropertyColumnNames( i ), dialect );
		}

		public string GetDiscriminatorAlias( string suffix )
		{
			// NOTE: this assumes something about how PropertySelectFragment is implemented by the subclass!
			// was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried
			// to remove that unquoting and missing aliases..		
			return hasSubclasses ?
				new Alias( suffix ).ToAliasString( DiscriminatorAlias, dialect ) :
				null;
		}

		protected abstract string DiscriminatorAlias { get; }

		public object LoadByUniqueKey( string propertyName, object uniqueKey, ISessionImplementor session )
		{
			return ( ( EntityLoader ) uniqueKeyLoaders[ propertyName ] ).LoadByUniqueKey( session, uniqueKey );
		}

		public string[ ] GetUniqueKeyColumnNames( string propertyName )
		{
			return ( string[ ] ) uniqueKeyColumns[ propertyName ];
		}

		public bool IsCollection
		{
			get { return false; }
		}

		public bool ConsumesAlias()
		{
			return true;
		}

		public virtual IType GetPropertyType( string path )
		{
			IType propertyType = typesByPropertyName[ path ] as IType;
			if( propertyType == null )
			{
				throw new MappingException( string.Format( "property does not exist: {0}", path ) );
			}
			return propertyType;
		}

		protected bool HasSelectBeforeUpdate
		{
			get { return selectBeforeUpdate; }
		}

		protected abstract SqlString VersionSelectString { get; }

		/// <summary>
		/// Retrieve the version number
		/// </summary>
		/// <param name="id"></param>
		/// <param name="session"></param>
		/// <returns></returns>
		public object GetCurrentVersion( object id, ISessionImplementor session )
		{
			if( log.IsDebugEnabled )
			{
				log.Debug( "Getting version: " + MessageHelper.InfoString( this, id ) );
			}

			try
			{
				IDbCommand st = session.Batcher.PrepareQueryCommand( VersionSelectString, false );
				IDataReader rs = null;
				try
				{
					IdentifierType.NullSafeSet( st, id, 0, session );
					rs = session.Batcher.ExecuteReader( st );
					if( !rs.Read() )
					{
						return null;
					}
					if( !IsVersioned )
					{
						return this;
					}
					return VersionType.NullSafeGet( rs, VersionColumnName, session, null );
				}
				finally
				{
					session.Batcher.CloseQueryCommand( st, rs );
				}
			}
			catch( Exception ex )
			{
				throw Convert( ex, "could not retrieve version: " + MessageHelper.InfoString( this, id ) );
			}
		}

		/// <summary>
		/// Do a version check
		/// </summary>
		/// <param name="id"></param>
		/// <param name="version"></param>
		/// <param name="obj"></param>
		/// <param name="lockMode"></param>
		/// <param name="session"></param>
		public virtual void Lock( object id, object version, object obj, LockMode lockMode, ISessionImplementor session )
		{
			if( lockMode != LockMode.None )
			{
				if( log.IsDebugEnabled )
				{
					log.Debug( "Locking entity: " + MessageHelper.InfoString( this, id ) );
					if( IsVersioned )
					{
						log.Debug( "Version: " + version );
					}
				}

				try
				{
					IDbCommand st = session.Batcher.PrepareCommand( GetLockString( lockMode ) );
					IDataReader rs = null;

					try
					{
						IdentifierType.NullSafeSet( st, id, 0, session );
						if( IsVersioned )
						{
							VersionType.NullSafeSet( st, version, IdentifierColumnNames.Length, session );
						}

						rs = session.Batcher.ExecuteReader( st );
						if( !rs.Read() )
						{
							throw new StaleObjectStateException( MappedClass, id );
						}
					}
					finally
					{
						session.Batcher.CloseCommand( st, rs );
					}
				}
				catch( Exception sqle )
				{
					throw Convert( sqle, "could not lock: " + MessageHelper.InfoString( this, id ) );
				}
			}
		}

		protected object GetGeneratedIdentity( object obj, ISessionImplementor session, IDataReader rs )
		{
			object id;

			try
			{
				if( !rs.Read() )
				{
					throw new HibernateException( "The database returned no natively generated identity value" );
				}
				id = IdentifierGeneratorFactory.Get( rs, IdentifierType.ReturnedClass );
			}
			finally
			{
				rs.Close();
			}

			if( log.IsDebugEnabled )
			{
				log.Debug( "Natively generated identity: " + id );
			}

			return id;
		}

		public object[ ] GetCurrentPersistentState( object id, object version, ISessionImplementor session )
		{
			if( !HasSelectBeforeUpdate )
			{
				return null;
			}

			if( log.IsDebugEnabled )
			{
				log.Debug( "Getting current persistent state for: " + MessageHelper.InfoString( this, id ) );
			}

			IType[ ] types = PropertyTypes;
			object[ ] values = new object[types.Length];
			bool[ ] includeProperty = PropertyUpdateability;
			try
			{
				IDbCommand st = session.Batcher.PrepareCommand( ConcreteSelectString );
				IDataReader rs = null;
				try
				{
					IdentifierType.NullSafeSet( st, id, 0, session );
					if( IsVersioned )
					{
						VersionType.NullSafeSet( st, version, IdentifierColumnNames.Length, session );
					}
					rs = session.Batcher.ExecuteReader( st );
					if( !rs.Read() )
					{
						throw new StaleObjectStateException( MappedClass, id );
					}
					for( int i = 0; i < types.Length; i++ )
					{
						if( includeProperty[ i ] )
						{
							values[ i ] = types[ i ].Hydrate( rs, GetPropertyAliases( string.Empty, i ), session, null ); //null owner ok??
						}
					}
				}
				finally
				{
					session.Batcher.CloseCommand( st, rs );
				}
			}
			catch( Exception sqle )
			{
				throw Convert( sqle, "error retrieving current persistent state" );
			}

			return values;
		}

		protected abstract string VersionedTableName { get; }

		/// <summary>
		/// Generate the SQL that selects the version number by id
		/// </summary>
		/// <returns></returns>
		protected SqlString GenerateSelectVersionString( ISessionFactoryImplementor factory )
		{
			SqlSimpleSelectBuilder builder = new SqlSimpleSelectBuilder( factory );
			builder.SetTableName( VersionedTableName );

			if( IsVersioned )
			{
				builder.AddColumn( VersionColumnName );
			}
			else
			{
				builder.AddColumns( IdentifierColumnNames );
			}

			builder.AddWhereFragment( IdentifierColumnNames, IdentifierType, " = " );

			return builder.ToSqlString();
		}

		protected abstract SqlString ConcreteSelectString { get; }

		protected OptimisticLockMode OptimisticLockMode
		{
			get { return optimisticLockMode; }
		}

		public bool IsManyToMany
		{
			get { return false; }
		}

		public object CreateProxy( object id, ISessionImplementor session )
		{
			return proxyFactory.GetProxy( id, session );
		}

		/// <summary>
		/// Transform the array of property indexes to an array of booleans
		/// </summary>
		/// <param name="dirtyProperties"></param>
		/// <returns></returns>
		protected bool[ ] GetPropertiesToUpdate( int[ ] dirtyProperties )
		{
			bool[ ] propsToUpdate = new bool[HydrateSpan];
			for( int j = 0; j < dirtyProperties.Length; j++ )
			{
				propsToUpdate[ dirtyProperties[ j ] ] = true;
			}
			if( IsVersioned )
			{
				propsToUpdate[ VersionProperty ] = true;
			}

			return propsToUpdate;
		}

		public override string ToString()
		{
			return StringHelper.Root( GetType().FullName ) + '(' + className + ')';
		}

		/// <summary>
		/// Get the column names for the numbered property of <em>this</em> class
		/// </summary>
		/// <param name="i"></param>
		/// <returns></returns>
		public abstract string[ ] GetPropertyColumnNames( int i );

		public SqlString SelectFragment( string alias, string suffix, bool includeCollectionColumns )
		{
			return SelectFragment( alias, suffix );
		}

		protected ADOException Convert( Exception sqlException, string message )
		{
			return ADOExceptionHelper.Convert( /* sqlExceptionConverter, */ sqlException, message );
		}


		public abstract SqlString QueryWhereFragment( string alias, bool innerJoin, bool includeSubclasses );

		public abstract object DiscriminatorSQLValue { get; }

		public abstract void Delete( object id, object version, object obj, ISessionImplementor session );

		public abstract object[ ] PropertySpaces { get; }

		public abstract void Insert( object id, object[ ] fields, object obj, ISessionImplementor session );

		public abstract object Insert( object[ ] fields, object obj, ISessionImplementor session );

		public abstract object Load( object id, object optionalObject, LockMode lockMode, ISessionImplementor session );

		public abstract void PostInstantiate( ISessionFactoryImplementor factory );

		public abstract void Update( object id, object[ ] fields, int[ ] dirtyFields, object[ ] oldFields, object oldVersion, object obj, ISessionImplementor session );

		public abstract int CountSubclassProperties();

		public abstract IType DiscriminatorType { get; }

		public abstract OuterJoinFetchStrategy EnableJoinedFetch( int i );

		public abstract SqlString FromJoinFragment( string alias, bool innerJoin, bool includeSubclasses );

		public abstract SqlString FromTableFragment( string alias );

		public abstract System.Type GetSubclassForDiscriminatorValue( object value );

		public abstract IType GetSubclassPropertyType( int i );

		public abstract bool IsDefinedOnSubclass( int i );

		public abstract SqlString PropertySelectFragment( string alias, string suffix );

		public abstract string TableName { get; }

		public abstract string[ ] ToColumns( string name, int i );

		public abstract SqlString WhereJoinFragment( string alias, bool innerJoin, bool includeSubclasses );

		public abstract string DiscriminatorColumnName { get; }

		public abstract string[ ] GetSubclassPropertyColumnNames( int i );

		public abstract string GetSubclassPropertyTableName( int i );

		public abstract string GetSubclassPropertyName( int i );

		public abstract bool IsCacheInvalidationRequired { get; }

		public bool IsUnsavedVersion( object[ ] values )
		{
			if( !IsVersioned )
			{
				return false;
			}

			object result = unsavedVersionValue.IsUnsaved( values[ VersionProperty ] );
			if( result != null )
			{
				return ( bool ) result;
			}

			return true;
		}
	}
}