<!-- <!DOCTYPE chapter SYSTEM "../../docbook-xml/docbookx.dtd"> -->
<!--
  This is part of NHibernateEg documentation.
  Copyright (C) 2006, Pierre Henri Kuaté.
  See the GNU Free Documentation License for copying conditions.
-->
<chapter id="NHibernateEg.Tutorial1A">
	<title>NHibernateEg.Tutorial1A</title>


	<abstract id="NHibernateEg.Tutorial1A-abstract">
		<title>Overview</title>

		<para>This tutorial is an introduction to NHibernate to new users.</para>
		<para>
			Here you will discover how to set up NHibernate and use it.
			We will create a non-interactive Console Application to do some basic operations.
		</para>
		<para>
			You should have all the <link linkend="Preface-Requirements">requirements</link>
			and the <link linkend="Preface-GetNHibernateEg">source code</link>
			(or at least the binary files).
		</para>
	</abstract>


	<section id="NHibernateEg.Tutorial1A-Presentation">
		<title>Presentation of Order and Shop</title>

		<para>The application of this tutorial mimics a (very simple) shop. The main (and only) managed class is the <classname>Order</classname>.</para>

		<para>
			<classname>Order</classname> is a class which has an <emphasis role="strong">identifier</emphasis>
			that makes each instance unique in the database. Its properties are:
			<itemizedlist>
				<listitem><para>A <emphasis role="strong">Date</emphasis> telling when the order was created</para></listitem>
				<listitem><para>The <emphasis role="strong">name of the product</emphasis> ordered (for simplicity sake, an order can only reference one product and it is its name that is stored)</para></listitem>
				<listitem><para>The <emphasis role="strong">quantity</emphasis> of items (of the product) ordered</para></listitem>
				<listitem><para>The <emphasis role="strong">total price</emphasis> of this order (that is: quantity * unit price)</para></listitem>
			</itemizedlist>
		</para>

		<para>
			<classname>Shop</classname> is a class that can be used to do some operations related to <classname>Order</classname>. You can ask the shop to:
			<itemizedlist>
				<listitem><para><emphasis role="strong">Generate</emphasis> some random orders; it is useful to fill the database so that you can directly operate on it</para></listitem>
				<listitem><para><emphasis role="strong">Print out some fields</emphasis> of all orders in the database</para></listitem>
				<listitem><para><emphasis role="strong">Load</emphasis> an order: Get the row and convert it to an instance of the class <classname>Order</classname></para></listitem>
				<listitem><para><emphasis role="strong">Save/Update/Delete</emphasis> an order (in the database)</para></listitem>
			</itemizedlist>
		</para>

		<para>Now, run the executable file <filename>NHibernateEg.Tutorial1A.exe</filename> to see all these operations in action.</para>
		<note>
			<title>Before running this application</title>
			<para>
				You may need to configure the access to your database.
				Open the file <filename>NHibernateEg.Tutorial1A.exe.config</filename>.
				By default, this application uses a Microsoft Access database named
				<filename>nhibernate.mdb</filename>.
				The connection is done using the Microsoft Jet 4.0 Database Engine.
			</para>
			<para>
				If you want to use a Microsoft SQL Server 2000 (or MSDE) database, change the line:
				<literal>&lt;add key="Database" value="Access" /&gt;</literal>
				to <literal>&lt;add key="Database" value="MSSQL" /&gt;</literal>.
			</para>
			<para>
				If you want to use a MySQL database, change the line:
				<literal>&lt;add key="Database" value="Access" /&gt;</literal>
				to <literal>&lt;add key="Database" value="MySQL" /&gt;</literal>.
				And make sure that the files <filename>MySql.Data.dll</filename>
				and <filename>ICSharpCode.SharpZipLib.dll</filename> are in your path
				(they should already be in the current directory).
			</para>
			<para>
				You can also change the related <literal>Connection String</literal> if required.
				Set the <emphasis>value</emphasis> of: <literal>Access.ConnectionString</literal>
				(for Microsoft Access), <literal>MSSQL.ConnectionString</literal> (for SQL Server)
				or <literal>MySQL.ConnectionString</literal> (for MySQL).
			</para>
		</note>

		<para>
			Note that you just have to create the database and configure its access;
			this application will fill it (after dropping the conflicting tables).
		</para>

		<para>When running this application, you should get something like:</para>
		<programlisting>
Application is starting...

Configuration of NHibernate...

Use database: &lt;Access&gt;
ConnectionString: &lt;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=nhibernate.mdb&gt;

NHibernate.Mapping.Attributes.HbmSerializer.Default.Serialize()...

new NHibernate.Tool.hbm2ddl.SchemaExport(cfg).Create()...
drop table SimpleOrder
Unsuccessful: Table 'SimpleOrder' doesn't exist.
create table SimpleOrder (Id INT !!! REPLACE THE PRECEEDING 'INT' AND THIS PLACE
HOLDER WITH 'COUNTER' !!!, `Date` DATETIME null, Product TEXT(255) not null,
Quantity INT null, TotalPrice INT null, primary key (Id))


sessionFact = cfg.BuildSessionFactory();



Saving 3 aleatory orders...

3 orders found!
  Order N°1,  Date=2005-12-06 23:01:03Z,  Product=P1
  Order N°2,  Date=2005-12-06 23:01:03Z,  Product=P2
  Order N°3,  Date=2005-12-06 23:01:03Z,  Product=P3

Loading order N° 1...

Order N°1
 Date = tuesday 6 december 2005 22:01:03
 Product=P1 (updated),  Quantity=3,  TotalPrice=9

Update the order N° 1...

Save the order N° 0...

Change the time zone of all orders: n=25...
4 updated orders!

Deleting the order N° 2...

3 orders found!
  Order N°1,  Date=2005-12-08 00:01:03Z,  Product=P1 (updated)
  Order N°3,  Date=2005-12-08 00:01:03Z,  Product=P3
  Order N°4,  Date=2005-12-08 00:01:04Z,  Product=New

Application is closed!
</programlisting>

		<para>
			If you get an exception, read it to understand what the exact problem is
			(it is probably related to your database installation or your connection string).
		</para>
		<para>
			You can safely ignore the messages just after the call to
			<methodname>SchemaExport(cfg).Create()</methodname> as long as they are not exceptions.
		</para>
		<para>
			Study this output to understand what we will achieve in the next sections.
		</para>
		<para>
			Here is the code of the method <methodname>Program.Main()</methodname> which generate this output:
		</para>
		<programlisting>
	string <emphasis role="strong">database</emphasis> = System.Configuration.ConfigurationSettings.AppSettings["Database"];
	string <emphasis role="strong">connectionString</emphasis> = System.Configuration.ConfigurationSettings.AppSettings[database + ".ConnectionString"];

	Shop shop = new <link linkend="NHibernateEg.Tutorial1A-Configuration">Shop</link>(database, connectionString);

	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Create">GenerateRandomOrders</link>(3);

	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Retrieve">WriteAllOrders</link>();

	Order o = shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Retrieve">LoadOrder</link>(1);

	o.Product += " (updated)";
	shop.Write(o);
	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Update">Save</link>(o);

	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Update">Save</link>( new Order("New", 4, 2) );

	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Update">ChangeTimeZone</link>(25);

	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Delete">Delete</link>(2);

	shop.<link linkend="NHibernateEg.Tutorial1A-CRUD.Retrieve">WriteAllOrders</link>();</programlisting>

		<para>
			The strings <emphasis role="strong">database</emphasis> and <emphasis role="strong">connectionString</emphasis>
			are extracted from the file <filename>NHibernateEg.Tutorial1A.exe.config</filename>
			and sent to the <classname>Shop</classname> for its configuration.
		</para>
		<para>
			Then we do some CRUD operations on <classname>Order</classname>:
			<link linkend="NHibernateEg.Tutorial1A-CRUD.Create">Create</link>,
			<link linkend="NHibernateEg.Tutorial1A-CRUD.Retrieve">Retrieve</link>,
			<link linkend="NHibernateEg.Tutorial1A-CRUD.Update">Update</link> and
			<link linkend="NHibernateEg.Tutorial1A-CRUD.Delete">Delete</link>.
			Their implementations will exhibit the usage of NHibernate for basic operations.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-ADO.NET">
		<title>Quick review of ADO.NET methods</title>

		<para>If you are familiar with ADO.NET, you can quickly create the application we described following these steps:
			<itemizedlist>
				<listitem><para>Creation of tables in DB + Typed DataSet (can be generated - optional)</para></listitem>
				<listitem><para>Creation of DbConnection + DataAdapters + Commands (can be generated)</para></listitem>
				<listitem><para>Application lifecycle (=> implementation of CRUD operations)</para></listitem>
			</itemizedlist>
		</para>

		<para>This method has some drawbacks (which increase with the complexity of the software):
			<itemizedlist>
				<listitem><para>Lack of flexibility / hard to maintain</para></listitem>
				<listitem><para>Hard to cleanly apply <emphasis role="strong">Object-Oriented Programming</emphasis> (OOP)</para></listitem>
				<listitem><para>Hard to separate the Domain Model from the database</para></listitem>
			</itemizedlist>
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-ORM.NHibernate">
		<title>Using Object / Relational Mapping and NHibernate</title>

		<para>After the theoric presentation made in <xref linkend="Preface-ORM" />, we will focus on the practical aspect.</para>
		<para>
			An Object / Relational Mapping solution allows focusing on the object model when designing an application.
			The database is abstracted by the persistence framework.
		</para>
		<para>
			While implementing the Shop, you will see that we almost never speak about the database (except to configure its access)
			and we will never manipulate tables/rows or SQL queries.
		</para>

		<para>You will discover the benefits of this technology while using it.</para>
		<para>
			The step zero is to create a Console Application and add the libraries:
			<filename>NHibernate.dll</filename>, <filename>log4net.dll</filename>
			and <filename>NHibernate.Mapping.Attributes.dll</filename> as references.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-Order">
		<title>Implementation of Order and introduction to NHibernate.Mapping.Attributes</title>

		<para>
			Now, we are going to implement the class <classname>Order</classname>.
			That is: Create the class, add the fields / properties and the methods (in a C# file).
		</para>

		<para>
			To manipulate the classes, NHibernate needs a mapping between these classes and the database tables.
			Here, we use the <emphasis role="strong">NHibernate.Mapping.Attributes</emphasis>
			to provide this mapping information.
		</para>
		<formalpara>
			<title>NHibernate.Mapping.Attributes uses .NET attributes to define the mapping.</title>
			<para>
				Basically, for each element in your classes, you put the right attribute on it so that
				NHibernate will know how this element is mapped to its equivalent in the database.
				Each attribute can have many properties used to specify how the mapping should work.
				Read <ulink url="http://nhibernate.sourceforge.net/nh-docs/html/NHibernate.Mapping.html">
				NHibernate mapping reference documentation</ulink> to understand their meaning.
			</para>
		</formalpara>

		<para>Here is the implementation of the class <classname>Order</classname>:</para>

		<section id="NHibernateEg.Tutorial1A-Order.Header">
			<title>The class header</title>
			<programlisting>
	[NHibernate.Mapping.Attributes.<classname>Class</classname>(<literal>Table="SimpleOrder"</literal>)]
	public class <classname>Order</classname>
	{
	}</programlisting>
			<para>
				The .NET attribute <classname>[Class]</classname> is used to tell to NHibernate that this is a mapped class.
				With <literal>Table="SimpleOrder"</literal>, we give the name of the database table in which orders are stored.
			</para>
			<para>
				No special interface has to be implemented for mapped classes nor do you have to subclass from a special
				root persistent class. NHibernate also doesn't require any build time processing, it relies solely on .NET reflection.
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Id">
			<title>The identifier and its generator</title>
			<programlisting>
	private int <methodname>_id</methodname> = 0;
	[NHibernate.Mapping.Attributes.<classname>Id</classname>(<literal>Name="Id"</literal>)]
		[NHibernate.Mapping.Attributes.<classname>Generator</classname>(1, <literal>Class="native"</literal>)]
	public virtual int <methodname>Id</methodname>
	{
		get { return _id; }
	}</programlisting>
			<para>
				The identifier is defined with the attribute <classname>[Id]</classname>.
				Don't forget to set its name (it can not be guessed).
			</para><para>
				The identifier can be assigned by the database, the application (you) or NHibernate.
				Read the documentation for more details on these options.
				The attribute <classname>[Generator]</classname> is used to select one of these strategies.
				We let the database choose the identifier, that's why we write <literal>Class="native"</literal>.
			</para><para>
				There is no <literal>set { ... }</literal> because the Id should never be changed
				(only NHibernate changes it when it is loaded/persisted).
				You may need it if you choose a generation strategy which requires setting the identifier manually.
			</para><para>
				As you can see, we have two attributes on this property (and there can be even more).
				<classname>[Generator]</classname> is indented to stress that it belongs to <classname>[Id]</classname>;
				and "1" (same as <literal>Position=1</literal>) tells that it comes after <classname>[Id]</classname>
				(which position is "0"); .NET attributes are not automatically ordered.
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Properties">
			<title>The properties</title>
			<programlisting>
	private System.DateTime <methodname>_date</methodname> = System.DateTime.Now;
	private string <methodname>_product</methodname>;
	private int <methodname>_quantity</methodname>;
	private int <methodname>_totalPrice</methodname>;

	[NHibernate.Mapping.Attributes.<classname>Property</classname>(Column="`Date`")]
	public virtual System.DateTime <methodname>Date</methodname>
	{
		get { return _date; }
	}

	[NHibernate.Mapping.Attributes.<classname>Property</classname>(<literal>NotNull=true</literal>)]
	public virtual string <methodname>Product</methodname>
	{
		get { return _product; }
		set { _product = value; }
	}

	[NHibernate.Mapping.Attributes.<classname>Property</classname>]
	public virtual int <methodname>Quantity</methodname>
	{
		get { return _quantity; }
		set { _quantity = value; }
	}

	[NHibernate.Mapping.Attributes.<classname>Property</classname>]
	public virtual int <methodname>TotalPrice</methodname>
	{
		get { return _totalPrice; }
		set { _totalPrice = value; }
	}</programlisting>
			<para>
				<classname>[Property]</classname> is used for fields that directly map to database's columns.
				The type of the property and the column should be compatible.
			</para><para>
				As "Date" is a reserved word in most RDBMS, we need to quote its column name;
				this is done using: <literal>Column="`Date`"</literal>.
			</para><para>
				<literal>NotNull=true</literal> is written because the product's name should not be null.
				If you want to have nullable properties (for bool/int/float/DateTime/...),
				you can use the <ulink url="http://nhibernate.sourceforge.net/nh-docs/html/Nullables.html">Nullables</ulink>
				library (it is distributed in the NHibernateContrib package).
			</para><para>
				If you wonder how NHibernate can set read-only properties, you will see that
				<link linkend="NHibernateEg.Tutorial1A-Configuration">NHibernate is configured to use the private fields</link>.
				The advantage of this setting is that you can use the properties names in Queries
				and as NHibernate accesses directly to fields, it doesn't execute eventual business logic contained in the properties.
				Actually, NHibernate can use public/protected/private fields/properties.
			</para><para>
				All your members (properties, methods and events) which access
				these fields directly should be <literal>virtual</literal>;
				it is required when lazy loading is enable on the mapped class
				(it is used in <xref linkend="NHibernateEg.Tutorial1B" />).
			</para><para>
				Therefore, if you have a member which is not virtual
				(or doesn't belong the entity) and which need to access to a field,
				it should use a <emphasis role="strong">virtual</emphasis> member of the mapped class
				(directly or not); most of the time, the virtual property of this field.
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Methods">
			<title>The methods</title>
			<programlisting>
	public <methodname>Order</methodname>()
	{
	}

	public <methodname>Order</methodname>(string product, int unitPrice, int quantity)
	{
		this.Product = product;
		this.Quantity = quantity;
		this.ComputeTotalPrice(unitPrice);
	}

	public void <methodname>ComputeTotalPrice</methodname>(int unitPrice)
	{
		this.TotalPrice = unitPrice * this.Quantity;
	}

	public <emphasis role="strong">virtual</emphasis> void <methodname>ChangeTimeZone</methodname>(int n)
	{
		this._date = this.Date.AddHours(n);
	}</programlisting>
			<para>
				As you can see, fields are never used directly;
				the only exception is <methodname>ChangeTimeZone()</methodname>
				which is <emphasis role="strong">virtual</emphasis>.
			</para><para>
				The class <classname>Order</classname> has a constructor
				which takes no parameter (<literal>public Order()</literal>).
				This is required as NHibernate needs it to create instances internally.
				But this constructor can be <literal>protected</literal>
				and even <literal>private</literal>
				if lazy loading is not enable for your entity.
			</para>
		</section>

		<section id="NHibernateEg.Tutorial1A-Order.Remarks">
			<title>Few remarks</title>
			<para>
				If you don't set the name of the table/column (in the attributes) where the class/property is loaded/saved,
				NHibernate will guess that they have the same name.
			</para>
			<para>
				To fully understand NHibernate.Mapping.Attributes, you should read
				<ulink url="http://nhibernate.sourceforge.net/nh-docs/html/NHibernate.Mapping.Attributes.html">its documentation</ulink>.
				And NHibernate documentation contains explanations for all mapping.
			</para>
			<para>
				As you read other articles/samples, you will discover that
				the mapping information is stored in <filename>.hbm.xml</filename> files.
				In fact, using attributes is a simpler and nicer way
				to generate this information (it is also far less verbose).
				Anyway, someday, as you progress in your usage of NHibernate,
				you will probably have to hand-write these files.
				And don't worry, these techniques can be mixed and
				you can even save attributes information into <filename>.hbm.xml</filename> files.
			</para>
		</section>
	</section>


	<section id="NHibernateEg.Tutorial1A-Configuration">
		<title>Configuration of NHibernate (database and mapping)</title>

		<para>
			This configuration is done in the constructor of <classname>Shop</classname>:
			<literal>public Shop(string database, string connectionString)</literal>.
		</para>

		<para>
			Before configuring NHibernate, there is a library
			you need to know: <emphasis role="strong">log4net</emphasis>.
		</para>
		<formalpara>
			<title>log4net is a logging system</title>
			<para>
				Basically, it receives log messages, filters them as you want
				and sends them wherever you want (in a file, on the console, in a database, as e-mail, etc.)
			</para>
		</formalpara>
		<para>
			Its configuration is in the file <filename>NHibernateEg.Tutorial1A.exe.config</filename>,
			in the section called <literal>&lt;log4net&gt;</literal>.
			You have to call one of the <methodname>log4net.Config.XmlConfigurator.Configure()</methodname>
			methods before using it; these methods read the configuration.
		</para><para>
			Finally, you put somewhere in your code:
			<programlisting>[assembly: log4net.Config.<classname>XmlConfigurator</classname>(<literal>Watch=true</literal>)]</programlisting>
			<literal>Watch=true</literal> tells to log4net to detect changes made on the configuration file at run-time
			(very useful to not have to restart your application...).
			For more information, go to <ulink url="http://log4net.sourceforge.net/">log4net website</ulink>.
		</para>

		<para>
			NHibernate needs some information to know how to communicate with the database:
			<itemizedlist>
				<listitem><para><literal>ConnectionProvider</literal>: <classname>NHibernate.Connection.DriverConnectionProvider</classname></para></listitem>
				<listitem><para><literal>Dialect</literal> and <literal>ConnectionDriver</literal>: they depend of your database.</para></listitem>
				<listitem><para><literal>ConnectionString</literal>: the string used to create a database connection.</para></listitem>
			</itemizedlist>
		</para>

		<para>
			The <literal>&lt;appSettings /&gt;</literal> section
			(in <filename>NHibernateEg.Tutorial1A.exe.config</filename>)
			makes it possible to switch from one database to another without changing a single line of code.
			Doing this with plain ADO.NET is not straightforward.
		</para>

		<para>
			Here is the code used to set this information:
			<programlisting>
// Create the object that will hold the configuration settings
// and fill it with the information to access to the Database
<classname>NHibernate.Cfg.Configuration</classname> <methodname>cfg</methodname> = new NHibernate.Cfg.Configuration();
cfg.SetProperty( NHibernate.Cfg.Environment.<methodname>ConnectionProvider</methodname>,
	<literal>"NHibernate.Connection.DriverConnectionProvider"</literal> );

if("<emphasis role="strong">Access</emphasis>" == database)
{
	cfg.SetProperty(NHibernate.Cfg.Environment.<methodname>Dialect</methodname>, <literal>"NHibernate.JetDriver.JetDialect, NHibernate.JetDriver"</literal>);
	cfg.SetProperty(NHibernate.Cfg.Environment.<methodname>ConnectionDriver</methodname>, <literal>"NHibernate.JetDriver.JetDriver, NHibernate.JetDriver"</literal>);
	cfg.SetProperty(NHibernate.Cfg.Environment.<methodname>ConnectionString</methodname>, <literal>connectionString</literal>);
}
else [...]</programlisting>
			Here, you can read the values to use when accessing a Microsoft Access database.
			If you want to use another RDBMS, you have to find its <literal>Dialect</literal> and
			<literal>ConnectionDriver</literal> (read NHibernate documentation).
			These values are set with the method <methodname>SetProperty()</methodname>.
			They can also be set using a XML file (this method is used in <xref linkend="NHibernateEg.Tutorial1B" />).
		</para>

		<para>
			We extract the mapping information using NHibernate.Mapping.Attributes:
			<programlisting>
System.IO.MemoryStream <emphasis role="strong">stream</emphasis> = new System.IO.MemoryStream(); // Where the information will be written in
// Ask to NHibernate to use fields instead of properties (in entities)
NHibernate.Mapping.Attributes.HbmSerializer.Default.<methodname>HbmDefaultAccess</methodname> = <literal>"field.camelcase-underscore"</literal>;<co id="NHibernateEg.Tutorial1A-HbmDefaultAccess-co" linkends="NHibernateEg.Tutorial1A-HbmDefaultAccess"/>
// Gather information from this assembly (can also be done class by class)
NHibernate.Mapping.Attributes.HbmSerializer.Default.<methodname>Serialize</methodname>( stream, <co id="NHibernateEg.Tutorial1A-Serialize-co" linkends="NHibernateEg.Tutorial1A-Serialize"/>
	System.Reflection.Assembly.<methodname>GetExecutingAssembly()</methodname> );
stream.Position = 0;
<literal>cfg.AddInputStream(stream);</literal><co id="NHibernateEg.Tutorial1A-AddInputStream-co" linkends="NHibernateEg.Tutorial1A-AddInputStream"/> // Send the Mapping information to NHibernate Configuration
stream.Close();</programlisting>
			<calloutlist>
				<callout arearefs="NHibernateEg.Tutorial1A-HbmDefaultAccess-co" id="NHibernateEg.Tutorial1A-HbmDefaultAccess"><para>
					With this setting, NHibernate will convert the name of the property in the camel case
					and will add an underscore before to get the name of the field that hold this data.
					Read the documentation to discover other <emphasis role="strong">naming strategies</emphasis>.
					If the field is private, it will use the reflection (so make sure that the application's security level allows this).
				</para></callout>
				<callout arearefs="NHibernateEg.Tutorial1A-Serialize-co" id="NHibernateEg.Tutorial1A-Serialize"><para>
					Here, NHibernate.Mapping.Attributes uses the .NET reflection to find all classes (in the ExecutingAssembly)
					with the attribute <classname>[Class]</classname> and fill the stream with information about these classes.
				</para></callout>
				<callout arearefs="NHibernateEg.Tutorial1A-AddInputStream-co" id="NHibernateEg.Tutorial1A-AddInputStream"><para>
					Once the stream is filled, we rewind it and send it to the NHibernate Configuration instance.
					It will parse its XML content to gather all the information NHibernate will need to manipulate your classes.
				</para></callout>
			</calloutlist>
		</para>

		<para>
			Now, we use a wonderful tool: <emphasis role="strong">SchemaExport</emphasis>:
			<programlisting>new NHibernate.Tool.hbm2ddl.<classname>SchemaExport</classname>(cfg).<methodname>Create</methodname>(true, true);</programlisting>
			Here, we create an instance of <classname>SchemaExport</classname> and we directly call the method <methodname>Create()</methodname>.
			It uses all the provided information (in the configuration instance) to generate and run a script
			that will create the tables and relationships in the database to hold the mapped classes.
			Note that it will fail to drop a table if this table has a reference which doesn't exist in the mapping; in this case, you must drop this table manually.
		</para>

		<para>
			Finally, we create the <classname>SessionFactory</classname>: (explanation in the next section)
			<programlisting>_sessionFactory = cfg.BuildSessionFactory();</programlisting>
			Note that <emphasis role="strong">_sessionFactory</emphasis> is an instance of the implementation
			of the interface <classname>ISessionFactory</classname>.
			And it will be destroyed only when the application is closed.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-Persistence">
		<title>Persistence API</title>

		<para>Before digging into NHibernate operations, there are some concepts that need to be explained:</para>

		<formalpara>
			<title>The notion of "Entity"</title>
			<para>
				In these articles, an entity is simply a mapped class.
				It implies that NHibernate know this class and can manipulate it.
			</para>
		</formalpara>

		<para>
			The main interface used to manipulate entities is <emphasis role="strong">ISession</emphasis>
			(full name: <classname>NHibernate.ISession</classname>).
		</para><para>
			You need <emphasis role="strong">one</emphasis> ISessionFactory for each database.
			It is generally created at the initialization of the application as it is the case here.
			Its implementation is thread-safe and exception-proof, so that it can live as long as your application is running.
		</para><para>
			A session is created by an <emphasis role="strong">ISessionFactory</emphasis>
			by calling the method <methodname>ISessionFactory.OpenSession()</methodname>.
		</para><para>
			You should use the <emphasis role="strong">session-per-request pattern</emphasis>;
			that is create one session for each user request.
			This is recommended because a session is not exception-proof (nor thread-safe).
			If an exception is thrown, you should rollback the transaction and close the session (don't try to recover it).
		</para>

		<para>
			The classic usage of a session (and its transaction) is:
			<programlisting>
	NHibernate.ISession session = null;
	NHibernate.ITransaction transaction = null;
	try
	{
		session = _sessionFactory.<methodname>OpenSession</methodname>();
		transaction = session.<methodname>BeginTransaction</methodname>();

		// CRUD operations here (with the session)

		transaction.<methodname>Commit</methodname>();
	}
	catch
	{
		if(transaction != null)
			transaction.<methodname>Rollback</methodname>();
		throw;
	}
	finally
	{
		if(session != null)
			session.<methodname>Close</methodname>();
	}</programlisting>
			As you can read in this code, we create the session, then its transaction.
			We use the session to do some CRUD operations; finally,
			we commit the changes and close the session (rollback if any exception is thrown).
		</para>
		<para>
			NHibernate transactions behave like ADO.NET transactions. The transaction is tightly coupled with the session.
			SQL commands are generated and ran only when calling
			<methodname>transaction.Commit()</methodname>.
			But it is possible to force that by calling <methodname>session.Flush()</methodname>.
		</para>
		<para>
			Note that creating the transaction can be optional
			(mainly when you just want to run SELECT operations);
			in this case, you can write:
			<programlisting>
	<literal>using</literal>(NHibernate.ISession session = _sessionFactory.<methodname>OpenSession()</methodname>)
	{
		// Retrieve data here (with the session)
	}</programlisting>
			<literal>using()</literal> will automatically close the session.
		</para>

		<para>
			An entity has a <emphasis role="strong">state</emphasis> which can change:
			The state you implicitly know is <emphasis role="strong">transient</emphasis>.
			When you create an instance of a class, this instance is transient.
		</para>
		<para>
			Once you send this instance to a session (to save/update it),
			this instance becomes <emphasis role="strong">persisted</emphasis>.
			At this level, the session has this instance in its cache.
		</para>
		<para>
			If you delete this instance, it is obviously not destroyed from the memory;
			the session will delete its row in the database and will remove it from its cache
			(which means that it becomes transient again).
			Note that an entity can not be attached to two opened sessions at the same time.
		</para>
		<para>
			Finally, when an instance is persisted and the session which persisted it is closed,
			this instance became <emphasis role="strong">detached</emphasis>.
			The difference with "transient" is that there might be some useful information
			that are hidden in this instance and can be used by another session.
		</para>
	</section>


	<section id="NHibernateEg.Tutorial1A-CRUD">
		<title>CRUD operations</title>

		<para>
			Now, we will use the session to do some basic CRUD operations
			(that is <emphasis role="strong">C</emphasis>reate,
			<emphasis role="strong">R</emphasis>etrieve,
			<emphasis role="strong">U</emphasis>pdate and
			<emphasis role="strong">D</emphasis>elete).
		</para>

		<para>For each operation, a method will be shown and explained.</para>


		<section id="NHibernateEg.Tutorial1A-CRUD.Create">
			<title>CREATE: Save</title>
			<para>
				<emphasis role="strong">Implementation of the method
				<classname>Shop</classname>.<methodname>GenerateRandomOrders()</methodname></emphasis>:
				Create "n" random orders and save them.
			</para>
			<programlisting>
	public void GenerateRandomOrders(int n)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;
	
		System.Console.Out.WriteLine("\nSaving " + n + " aleatory orders...");
		try
		{
			session = _sessionFactory.OpenSession();
			transaction = session.BeginTransaction();

			for(int i=0; i&lt;n; i++)
			{
				<literal>Order o = new Order();</literal>

				o.Product = "P" + (i+1).ToString();
				o.Quantity = n - i;
				o.ComputeTotalPrice(i * 10 + n);

				<literal>session.Save(o);</literal>
			}

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				In this method, orders are randomly created and filled. Then, the method
				<methodname>session.Save()</methodname> is used to save them.
			</para>
		</section>


		<section id="NHibernateEg.Tutorial1A-CRUD.Retrieve">
			<title>RETRIEVE: Query and Load/Get</title>
			<para>
				To retrieve entities, NHibernate has two query APIs:
				<itemizedlist>
					<listitem><para>
						The <emphasis role="strong">Hibernate Query Language</emphasis>
						(<emphasis role="strong">HQL</emphasis>) is a language similar to SQL but "object-oriented".
					</para></listitem>
					<listitem><para>
						The <emphasis role="strong">Query by Criteria API</emphasis> which provides classes to formulate type-safe queries.
					</para></listitem>
				</itemizedlist>
				These APIs return as result an <classname>IList</classname> which contains all the items matching the criteria.
			</para>

			<para>
				When you need to load an entity (knowing its identifier), you can either use
				<methodname>session.Load()</methodname> or <methodname>session.Get()</methodname>;
				send the type and the identifier of the entity to load it.
			</para>
			<para>
				<methodname>session.Load()</methodname> throws an exception
				if there is no entity in the database with this identifier and
				<methodname>session.Get()</methodname> simply returns <emphasis role="strong">null</emphasis> in this case.
				The session runs a query to retrieve the row, builds an instance, fills and returns it.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method
				<classname>Shop</classname>.<methodname>WriteAllOrders()</methodname></emphasis>:
				For each order (in the database), write the identifier, the date and the product name.
			</para>
			<programlisting>
	public void WriteAllOrders()
	{
		using(NHibernate.ISession session = _sessionFactory.OpenSession())
		{
			System.Collections.IList result = session.<methodname>Find</methodname>(<literal>"select o.Id, o.Date, o.Product from Order o"</literal>);

			System.Console.Out.WriteLine("\n" + result.Count + " orders found!");
			foreach(System.Collections.IList l in result)
				System.Console.Out.WriteLine("  Order N°"
					+ l[0] + ",  Date=" + ((System.DateTime)l[1]).ToString("u")
					+ ",  Product=" + l[2]);
		} // finally { session.Close(); }	is done by using()
	}</programlisting>
			<para>
				As you can see, there is no transaction here (needless)
				and <literal>using()</literal> will close the session at the end.
				The HQL query ran here is "<literal>select o.Id, o.Date, o.Product from Order o</literal>".
				This query is identical to what can be written in SQL.
				We ask the list of some items (the Id, Date and Product) in Order's table.
				These items are stored in an <classname>IList</classname> which means
				that we get an IList containing ILists.
			</para>
			<para>
				To build more complex queries, you can create an <classname>IQuery</classname> instance
				using the method <methodname>ISession.CreateQuery()</methodname>; it takes a HQL query
				and returns an instance which exposes some extra functionalities.
				And there are even few other alternatives. Read the documentation for more details.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method
				<classname>Shop</classname>.<methodname>LoadOrder()</methodname></emphasis>:
				Return the order with the specified identifier.
			</para>
			<programlisting>
	public Order LoadOrder(int id)
	{
		System.Console.Out.WriteLine("\nLoading order N° " + id + "...");
		using(NHibernate.ISession session = _sessionFactory.OpenSession())
			return <literal>session.Load(typeof(Order), id)</literal> as <classname>Order</classname>;
		// finally { session.Close(); }	is done by using()
	}</programlisting>
			<para>
				This method uses <methodname>session.Load()</methodname> because
				we know that it would be <emphasis role="strong">exceptional</emphasis>
				that the entity to load doesn't exist.
			</para>
		</section>


		<section id="NHibernateEg.Tutorial1A-CRUD.Update">
			<title>UPDATE: SaveOrUpdate / Save / Update</title>

			<para>
				<emphasis role="strong">Implementation of the method
				<classname>Shop</classname>.<methodname>Save()</methodname></emphasis>:
				Save or Update the order (in the database).
			</para>
			<programlisting>
	public void Save(Order o)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;

		// That's how the Session decide to save or to update; set NHMA.Id(UnsavedValue=x) to replace 0
		System.Console.Out.Write("\n"  +  (<literal>o.Id == 0  ?  "Save"  :  "Update"</literal>));
		System.Console.Out.WriteLine(" the order N° " + o.Id + "...");
		try
		{
			session = _sessionFactory.OpenSession();
			transaction = session.BeginTransaction();

			// NHibernate Session will automatically find out if it has to build an INSERT or an UPDATE
			<literal>session.SaveOrUpdate(o);</literal>

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				NHibernate uses a particular technique to know if it should issue INSERT or UPDATE commands:
				An identifier is defined with an unsaved value which is, by default,
				the value that it takes when it is created (an integer takes the value 0 at its creation).
				You can set <literal>[NHibernate.Mapping.Attributes.Id(UnsavedValue=?)]</literal>
				to replace the unsaved value. So a new entity will have the unsaved value as identifier
				and the session will know that it needs to insert this entity.
				Refer to the documentation to see how you can customize this behavior even more.
				There are still the methods <methodname>session.Save()</methodname>
				and <methodname>session.Update()</methodname> if you need them.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method
				<classname>Shop</classname>.<methodname>ChangeTimeZone()</methodname></emphasis>:
				Add 'n' hours to the date of all orders.
			</para>
			<programlisting>
	public void ChangeTimeZone(int n)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;

		System.Console.Out.WriteLine("\nChange the time zone of all orders: n=" + n + "...");
		try
		{
			session = _sessionFactory.OpenSession();
			transaction = session.BeginTransaction();

			System.Collections.IList orders = <literal>session.CreateCriteria(typeof(Order)).List();</literal>
			// same as: <literal>session.Find("from Order");</literal>
			foreach(Order o in orders)
				o.<methodname>ChangeTimeZone</methodname>(n);
			// It is useless to call Update(), the Session will automatically
			// detect modified entities (as long as it loaded them)
			System.Console.Out.WriteLine(orders.Count + " updated orders!");

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				Here, we load all orders using:
				<programlisting>session.<literal>CreateCriteria(typeof(Order))</literal>.List()</programlisting>
				Equivalent to: <programlisting>session.Find(<literal>"from Order"</literal>)</programlisting>
				"select" is not needed when you want entities (in simple queries), but you can write it like this:
				<programlisting>session.Find(<literal>"select o from Order o"</literal>)</programlisting>
			</para>
			<para>
				Once loaded, these entities are kept in the session cache (first-level).
				This means that you don't need to save them again.
				When doing <methodname>transaction.Commit()</methodname>;
				the session will browse its cache to detect changed entities and it will persist them.
				This feature is called <emphasis role="strong">transparent persistence</emphasis>.
			</para>
		</section>


		<section id="NHibernateEg.Tutorial1A-CRUD.Delete">
			<title>DELETE: Delete(HQL) and Delete(Entity)</title>
			<para>
				There are two ways to delete entities:
				You can either run a HQL query or send an entity for deletion.
			</para>
			<para>
				With HQL, NHibernate will first load all matching entities (to update its caches) and then,
				it will delete them (and delete linked entities by cascade if needed).
				If you already have an entity, you can call <methodname>session.Delete(entity)</methodname>.
			</para>

			<para>
				<emphasis role="strong">Implementation of the method
				<classname>Shop</classname>.<methodname>Delete()</methodname></emphasis>:
				Delete the order (in the database).
			</para>
			<programlisting>
	public void Delete(int id)
	{
		NHibernate.ISession session = null;
		NHibernate.ITransaction transaction = null;

		System.Console.Out.WriteLine("\nDeleting the order N° " + id + "...");
		try
		{
			session = _sessionFactory.OpenSession();
			transaction = session.BeginTransaction();

			session.<methodname>Delete</methodname>(<literal>"from Order o where o.Id = :Id"</literal>, id, <methodname>NHibernate.NHibernateUtil.Int32</methodname>);

			// Commit modifications (=> Build and execute queries)
			transaction.Commit();
		}
		catch
		{
			if(transaction != null)
				transaction.Rollback(); // Error => we MUST roll back modifications
			throw; // Here, we throw the same exception so that it is handled (printed)
		}
		finally
		{
			if(session != null)
				session.Close();
		}
	}</programlisting>
			<para>
				The new element here is the usage of <emphasis role="strong">parameter</emphasis>:
				an object (the id) and the descriptor of its type (<methodname>NHibernate.NHibernateUtil.Int32</methodname>).
			</para>
			<para>
				You can also write:
				<programlisting>session.Delete(<literal>"from Order o where o.Id = " + id</literal>);</programlisting>
				But it is not recommended to take this habit.
				Using parameters prevents some SQL injection attacks and escapes invalid characters.
				And you can also get slightly better performances.
			</para>
		</section>
	</section>


	<section id="NHibernateEg.Tutorial1A-Conclusion">
		<title>Conclusion</title>

		<para>
			In this tutorial, we designed a simple shop, we implemented its class Order,
			we configured NHibernate and implemented the Shop's methods (doing basic CRUD operations).
		</para>

		<para>
			The most obvious advantage of using an ORM (for beginners) is the
			<emphasis role="strong">simplicity when doing CRUD operations</emphasis>.
			When you are familiar with the API, you can load, save, update and delete entities
			without any knowledge of the underlying database;
			you don't even need to know anything about SQL.
			But this knowledge is still important if you want get the best performance.
		</para>

		<para>
			Another more important advantage is that your entities don't even know that they are ever persisted;
			which can be useful in complex applications.
			<emphasis role="strong">Persistence becomes an external service</emphasis> which is not intrusive here (almost).
		</para>

		<para>
			Finally, you can <emphasis role="strong">design your application with OOP in mind</emphasis>
			and then create a database that can keep your entities.
		</para>
		<para>
			But NHibernate is <emphasis role="strong">also impressive when dealing with legacy databases</emphasis>.
			You can take a classic relational database and map it to your object-oriented entities.
		</para>

		<para>
			You have to understand that if DataSet is not the perfect answer to every problem,
			<emphasis role="strong">ORM is neither perfect in every situation</emphasis>.
			Reporting and batch processing are situations where DataSet and DataReader might perform better.
			And it is probably less brainstorming to use them in straightforward applications.
			Note that all these techniques can cohabit in the same software; just choose the right tool for the right job.
		</para>

		<para>
			Now, I suggest you to try to do a Console Application similar to this one
			without looking at the tutorial/code too often. You may also try new things.
			After that, you will have a better understanding and memorize more information.
		</para>

		<para>
			A tool that you should really try is
			<ulink url="http://www.ayende.com/projects/nhibernate-query-analyzer.aspx">NHibernate Query Analyzer</ulink>.
			With it, you can edit NHibernate XML configuration files and mapping (<filename>.hbm.xml</filename>) files.
			You can also easily run HQL queries after setting up the configuration.
			To see it in action, download the flash videos available on its web site.
		</para>

		<para>
			You can find more sample and articles in the
			<ulink url="http://wiki.nhibernate.org/display/NH/Documentation">NHibernate Documentation</ulink>.
		</para>

		<para>
			And if you want to discuss about this tutorial, use
			<ulink url="http://nhibernate.sourceforge.net/forum/viewtopic.php?t=1309">this forum topic</ulink>.
			Use it only for topics directly linked to this tutorial;
			if you have some problems with your own tests, you should create a new topic (read <xref linkend="Support" />).
		</para>
	</section>

</chapter>
